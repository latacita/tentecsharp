%%==================================================================%%
%% Author : Pérez Ruiz, Alejandro                                   %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.1, 14/06/2011                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Capítulo Domain Engineering, Archivo raíz                        %%
%%==================================================================%%

\chapterheader{Ingeniería del Dominio}{Ingeniería del Dominio}
\label{chap:domain}

Este capítulo se describe la fase de \emph{ingeniería del dominio} (en inglés, \emph{Domain Engineering}) de nuestra línea de productos software. Dentro de dicha fase, se detalla la definición de la arquitectura de la familia de productos y se detallan las iteraciones más relevantes de este proceso de desarrollo. Las otras iteraciones, por motivos de espacio y con objeto de no aburrir al lector con detalles irrelevantes, simplemente se omiten.

\chaptertoc

\section{Definición Arquitectónica}

\input{domainEngineering/arquitectura.tex}

\section{Un Patrón para Permitir la Reescritura Usando Clases Parciales}

% \input{domainengineering/pattern.tex}

\section{Iteración 1: Sistema Base}

\input{domainEngineering/iteracionUno.tex}

\section{Iteración 2: Gestión de Sistemas de Control de Temperatura}

\input{domainEngineering/iteracionDos.tex}

\section{Iteración 3: WindowMng}
%% Section{Iteración 3: WindowMng}

% Muy resumida

La característica manejo de ventanas o \emph{WindowMng} en inglés, tiene como principal requisito permitir a los usuarios abrir o cerrar una ventana con una determinada apertura. Por cada ventana existirán dos dispositivos, uno de ellos será un sensor que únicamente se encargará de enviar al Gateway la apertura que tiene la ventana, y otro será el actuador, que es el destinado a recibir la información del Gateway para abrir o cerrar con una determinada apertura.

Al igual que ha ocurrido en la característica descrita en la sección anterior, se vuelve a definir la clase parcial \imp{Gateway} para extender la funcionalidad necesaria para controlar y manejar las ventanas. Las clases abstractas \imp{Actuator} y \imp{Sensor} vuelven a ser extendidas con los dispositivos específicos para esta característica. La figura \ref{domain:fig:designWindowMng} ilustra el diseño UML que representa lo descrito anteriormente.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/WindowMngDesign.eps} \\
 \caption{Diseño UML para la característica \emph{WindowMng}.}
 \label{domain:fig:designWindowMng}
\end{figure}

Para el caso de las dos interfaces gráficas se ha seguido un proceso similar que el utilizado en la característica \emph{HeaterMng}, es decir, volviendo a definir las clases parciales que implementan a las interfaces gráficas se añaden nuevos controles del tipo pestaña. De este modo las interfaces muestran un diseño como el representado en la figura \ref{domain:fig:GUIWindowMng}, en la cual en la parte superior de la izquierda se ilustra la interfaz gráfica del Gateway con la pestaña global que controla todas las ventanas, mientras que en la parte superior de la derecha se ilustra el diseño destinado a controlar una ventana específica. En la parte inferior de la figura se muestra la interfaz gráfica para el simulador.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/GUIWindowMng.eps} \\
 \caption{Diseño de las interfaces gráficas para la característia \emph{WindowMng}}
 \label{domain:fig:GUIWindowMng}
\end{figure}

Para las pruebas en esta característica se han realizado una serie de test, que han seguido el siguiente procedimiento:
\begin{enumerate}
\item Se han creado una serie de instancias del hogar inteligente con diferente número de ventanas repartidas por distintas habitaciones.
\item Por cada instancia se realizan los siguientes casos de prueba:
	\begin{enumerate}
		\item Se modifica la apertura de las todas las ventanas, a través de la pestaña de control global de la característica, en la interfaz gráfica del Gateway, y se comprueba en el simulador y en el propio Gateway.
		\item Por cada ventana se modifica su apertura, de modo individual a través de su pestaña específica.
	\end{enumerate}
\end{enumerate}

La siguiente sección describe el proceso de desarrollo de la característica \emph{SmartEnergyMng},que necesitará de la existencia de la característica de la sección actual, como la de la anterior.

\section{Iteración 4: SmartEnergyMng}
%\label{sec:domain:smartEnergy}
%% Section{Iteración 4: SmartEnergyMng}

%%% Introducción justificando por qué

%%% Requisitos específicos (muy resumidos)

%%% Diseño UML

%%% Implementación (explicar como se ha conseguido **Hacerlo bien**)

%%% Pruebas
La característica denominada control de energía inteligente o \emph{SmartEnergyMng} en inglés,tiene como particularidad que necesita del control de ventanas (WindowMng) y del control de calefacción (HeaterMng) para que se puede utilizar, ya que su función es por un lado, que siempre que los calefactores estén encendidos se cierren todas las ventanas para evitar pérdidas de energía, y por otro lado, almacenar los horarios de los habitantes, de este modo siempre que la casa esté vacía los calefactores serán apagados para ahorrar energía y se encenderán con la suficiente antelación para poder restablecer la temperatura elegida por el usuario.

Al igual que todas las demás características descritas en las secciones anteriores, se redefine la clase parcial \imp{Gateway} tal y como se muestra en la figura XX, a través de ello se añaden varios métodos que permiten implementar los requisitos. En primer lugar para desarrollar el requisito que almacena los horarios de los habitantes se utiliza el metalenguaje de etiquetas XML \cite{rusty:2004}, a través de él se almacena en un fichero el nombre, apellidos y los intervalos de tiempo en el que no se encuentra en casa cada habitante. Con el método \imp{findEmptyTime()}, mostrado en la figura XX \todo{PONER FIGURA}, se realizan las operaciones oportunas para calcular los intervalos de tiempo en los que la casa estará vacía, los cuales serán utilizados por el otro método denominado \imp{checkTime(int hours, int minutes)} para comprobar, cada vez que el tiempo sea modificado, si la casa está vacía, y en ese caso desconectar todos los calefactores o encenderlos en el caso de que el tiempo se aproxime a la llegada de los usuarios.

El siguiente requisito que es necesario implementar es el encargado de cerrar las ventanas cuando los calefactores estén funcionando, por lo que se nos presenta una situación que no se puede resolver a través de las clases parciales, debido a que en la característica HeaterMng tenemos un método en la clase \imp{Gateway} para ajustar la temperatura de un calefactor a través del actuador correspondiente, y por lo tanto, es necesario redefinir este método que modifica la temperatura de los calefactores para cada vez que sea llamado se encargue de cerrar las ventanas. Pero esto no es algo trivial de realizar con las clases parciales, ya que no poseen la propiedad de extender métodos o sobrescribirles, únicamente separan una clase en diferentes archivos, para que luego el compilador los junte. Por lo tanto, se ha tenido que desarrollar una alternativa que supla esta carencia de las clases parciales, por lo cual se ha creado un mecanismo que sigue el siguiente proceso:
\begin{enumerate}
\item Todos los métodos de la clase parcial \imp{Gateway}, en todas las características, han sido renombrados usando el nombre de la característica como prefijo, por ejemplo el método denominado \imp{heaterAdjustTemperature} de la característica HeaterMng pasará a llamarse \imp{heaterMng\_heaterAdjustTemperature}. De este modo evitaremos que existan ambigüedades de nombres entre métodos de distintas características.
\item Se definen los métodos que presentasen ambigüedad si no hubiésemos realizado el paso anterior en otra definición de la clase parcial \imp{Gateway} destinada exclusivamente a contener este tipo de métodos. El nombre del método será sin el prefijo de ninguna característica.
\item Los métodos definidos en el paso anterior contendrán llamadas a los métodos correspondientes, dependiendo de la característica que sea seleccionada. Por ejemplo, para el método \imp{heaterAdjustTemperature}, si se ha seleccionado la característica SmartEnergyMng se deberá llamar al método \imp{smartEnergyMng\_heaterAdjustTemperature}.El código del método tendrá un aspecto como el mostrado en la figura \ref{domain:fig:codSmartEnergy}.
\item Todas las llamadas a los métodos que sean susceptibles de ambigüedad serán sobre los métodos correspondientes creados en el paso anterior.
\end{enumerate}

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 public void heaterAdjustTemperature(int id_heater, double temperature)
01 {
02      smartEnergyMng_heaterAdjustTemperature(id_heater, temperature);
03 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del método heaterAdjustTemperature cuando la característica SmartEnergyMng está seleccionada}
\label{domain:fig:codSmartEnergy}
\end{figure}
Siguiendo este proceso se ha conseguido solucionar el primer problema que ha surgido al trabajar con líneas de productos software mediante las clases parciales de C\#.

Nuevamente se necesita definir las interfaces gráficas para esta característica, para el caso de la interfaz que representa al Gateway, únicamente se añade una nueva pestaña global que contendrá un botón que activa o desactiva el control inteligente de energía y un campo que permite introducir la temperatura que se quiere tener cuando se reconecten los calefactores después de que la casa haya estado vacía. Mientras que la interfaz gráfica que representa al simulador, implementa una nueva pestaña para esta característica, en la que se puede modificar el tiempo del sistema, puesto que el sistema no funciona bajo una construcción real de una hogar inteligente, por lo que de este modo se podrá modificar el tiempo a nuestro antojo para facilitar las tareas de simulación. Por otro lado también se ha añadido una lista con los intervalos de tiempo en la que la casa se encuentra vacía, tal y como se ilustra en la figura \ref{domain:fig:SimulatorSmartEnergyMng}.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/simulatorGUISmartEnergyMng.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el simulador en la característica de \emph{SmartEnergyMng}}
 \label{domain:fig:SimulatorSmartEnergyMng}
\end{figure}

Para realizar las pruebas correspondientes de esta característica se han dividido en varios tests, el primer de ellos es el encargado de verificar los métodos que se encargan de leer y encontrar en el fichero XML los horarios en los que la casa se encuentra vacía, para ello se ha modifica dicho fichero en varias ocasiones, en las cuales la mitad de las veces el número de habitantes era impar y en la otra mitad par, además de añadir de un modo aleatorio horarios a los habitantes, en los que al menos existiese un intervalo en el que la casa estuviese vacía en la mitad de las ocasiones.

Otro conjunto de tests son los destinados a comprobar que los calefactores se apagan y se encienden correctamente si la casa está vacía, por lo que nuevamente se utilizan los ficheros XML anteriores en los que la casa está vacía y se comprueba que si el control de energía inteligente está encendido se comporta correctamente. Por lo cual se crean una serie de instancias de la casa con diferente número de calefactores distribuidos por distintas habitaciones y se comprueba.

La última batería de tests es la encargada de comprobar que las ventanas son cerradas si el control de energía está encendido y alguno de los calefactores de la casa está encendido. Por lo tanto se crean diferentes estancias de la casa con distintas distribuciones de ventanas y calefactores en las habitaciones, y se comprueba que todas las ventanas son cerradas siempre y cuando se cumplan las dos condiciones anteriores.

La siguiente sección describirá brevemente las iteraciones restantes para terminar de implementar la ingeniería de domino de esta línea de productos software.


\section{Otras iteraciones}
%% Section{Otras iteraciones}

%% Muy resumido y destacando lo que te apetezca destacar
Como se ha podido observar en las iteraciones anteriores se sigue un procedimiento muy simular en todas ellas, ya que siempre se están utilizando las clases parciales como un mecanismo para añadir nueva funcionalidad a una clase existente.

En UML las características son agrupadas como paquetes. Un \emph{paquete} es definido en UML como un elemento de modelado usado para agrupar otros elementos de modelado, para de este modo obtener un espacio de nombres para los elementos agrupados.
La relación \emph{merge} entre dos paquetes, indica que el contenido de ambos es combinado, la especificación UML establece que esta relación se debe usar cuando los elementos de los paquetes tienen el mismo nombre y representan el mismo concepto\cite{omg:uml:2005}. Por lo que podemos definir un diagrama de paquetes como el mostrado en la figura \ref{domain:fig:packageDiagram}, en el que todas las características se conectan a través de una relación \emph{merge}. Por lo tanto, a través de la figura \ref{domain:fig:packageDiagram} se puede reflejar que todas las características realizan una combinación de sus elementos con el mismo nombre haciendo uso de las clases parciales.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/packageDiagram.eps} \\
 \caption{Diagrama de paquetes con todas las características.}
 \label{domain:fig:packageDiagram}
\end{figure}

Tras realizar todas las iteraciones necesarias para implementar la ingeniería de dominio, se consigue tener un sistema dividido que encapsula características que pueden ser combinadas y compiladas de diferentes maneras, siempre y cuando se respeten las restricciones básicas.

\section{Sumario}

En este capítulo se ha mostrado el proceso llevado a cabo para realizar la fase de ingeniería de dominio en esta línea de productos software, en la cual se han utilizado las clases parciales de C\# como principal mecanismo para encapsular las características. No obstante, las clases parciales presentan alguna limitación para encapsular correctamente, por lo que se han desarrollado y expuesto mecanismos para suplir estas limitaciones.

El siguiente capítulo mostrará como utilizando la infraestructura desarrollada anteriormente, se pueden crear aplicaciones específicas adaptadas a los requerimientos de los usuarios. 
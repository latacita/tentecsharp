%%==================================================================%%
%% Author : Pérez Ruiz, Alejandro                                   %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.1, 16/03/2011                                         %%                                                                                    %%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Capítulo Domain Engineering, Archivo raíz                        %%
%%==================================================================%%

\chapterheader{Ingeniería del Dominio}{Ingeniería del Dominio}
\label{chap:domain}

Este capítulo se describe la fase de \emph{ingeniería del dominio} (en inglés, \emph{Domain Engineering}) de nuestra línea de productos software. Dentro de dicha fase, se detalla la definición de la arquitectura de la familia de productos y se detallan las iteraciones más relevantes de este proceso de desarrollo. Las otras iteraciones, por motivos de espacio y con objeto de no aburrir al lector con detalles irrelevantes, simplemente se omiten. 

\chaptertoc
\section{Definición Arquitectónica}
%% Section{Definición Arquitectónica}
%%% Contar que es el gateway como lo controla todo
%%% Cuenta lo de los observadores
%%% Cuenta que el gateway viene a ser similar a un Mediator
El hogar inteligente posee una serie de dispositivos que se descomponen en sensores y actuadores. Los sensores son los encargados de obtener los datos del elemento al que pertenecen, como por ejemplo, los grados que hace en una habitación o la apertura que tiene una ventana. Los actuadores se encargan de ejecutar las ordenes, por ejemplo, de que una persiana se abra o se cierre o de que la calefacción se encienda a unos determinados grados.

Tanto los sensores como los actuadores se encuentran conectados a un dispositivo central que los coordina, el cual se conoce como puerta de enlace o Gateway. Dicho Gateway se encarga de recibir los datos de los sensores, procesarlos y enviar las ordenes adecuadas a los actuadores. De igual modo, el Gateway recibe órdenes de los usuarios que son ejecutadas por los actuadores para modificar los elementos de la casa.

Además el Gateway posee una lista de las plantas que tiene el hogar, a su vez cada planta contiene otra lista de las habitaciones que se encuentran en dicha planta, y un objeto tiempo que se encarga de simular el transcurso del tiempo en el sistema.

En la figura \ref{domain:fig:defArq} se puede observar el diseño UML que representa todo lo dicho anteriormente, quedando reflejado como el Gateway es la pieza central del sistema.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.45\linewidth]{domainEngineering/Images/definicionArq.eps} \\
 \caption{Diseño UML que muestra la definición arquitectónica}
 \label{domain:fig:defArq}
\end{figure}

Para que el usuario pueda monitorizar y controlar la situación de los elementos es necesario la creación de una interfaz gráfica que represente las funcionalidades propias del Gateway. De igual modo, es necesaria otra interfaz gráfica que juegue el papel de simulador, ya que la implementación presentada en este proyecto no está conectada a dispositivos reales, y por ello es necesario simular valores para los sensores, tales como la temperatura, y el tiempo del sistema. Ambas interfaces gráficas se conectarán al Gateway para poder comunicarse con todos los dispositivos.

Debido a que el Gateway simplifica la comunicación entre los objetos del sistema siendo éste un objeto que gestiona la distribución de mensajes entre sensores, actuadores, e interfaces gráficas, se puede decir que sigue el patrón de diseño denominado \emph{mediador}\cite{gamma:1994} (\emph{Mediator pattern}, en inglés).

En el diseño arquitectónico descrito anteriormente se observa que existen dependencias entre objetos de forma que cuando un objeto cambia de estado, todos sus objetos dependientes son notificados y actualizados. Tales dependencias son:
\begin{enumerate}
\item Las interfaces gráficas y el Gateway tienen que ser notificados y actualizados cada vez que un sensor cambie.
\item Tanto el Gateway como las interfaces gráficas tienen que ser actualizados cuando el tiempo actual del sistema cambie.
\end{enumerate}
Claramente esto puede ser modelado siguiendo el patrón de diseño llamado \emph{observador}\cite{gamma:1994} (\emph{Observer pattern}, en inglés), es decir, por cada objeto que vaya a ser observado es necesario crear una lista donde se registrarán todos los observadores, de este modo cada vez que se produzca una modificación en el objeto observado, éste utilizará la lista para notificar a todos sus observadores que se ha producido un cambio.

Con el diseño arquitectónico básico definido y teniendo en cuenta que el presente proyecto implementa una línea de productos software para hogares inteligentes, se debe encapsular cada una de las características ,para que posteriormente cada aplicación creada pueda ser compuesta de diferentes maneras. Por ello se hará uso de las clases parciales y la herencia para encapsular cada característica. Este proceso iterativo será descrito con mas detalle en las siguientes secciones.

\section{Iteración 1: Sistema Base}
%% Section{Iteracion 1: Base System}
%%% Requisitos específicos
%%% Diseño UML
%%% Diseño Interfaz Gráfica
%%% Implementación
El sistema base (\emph{Base System}, en inglés) es la característica que define la arquitectura base para el sistema, es decir, debe proporcionar a los usuarios el acceso a los servicios del Gateway a través de las interfaces gráficas de usuario y además permitir que el número de plantas y habitaciones sea variable. Para ello se define la clase parcial \imp{Gateway} que en cada nueva característica(control inteligente de luces, calefacción, ventanas...), será vuelta a definir, ya que cada vez que una misma clase parcial es definida se está dividiendo la clase en varios archivos de código fuente, que posteriormente cuando se compile la aplicación serán combinados.

Por lo tanto, el sistema base implementará el diseño UML mostrado en la sección anterior con la figura \ref{domain:fig:defArq}, con lo que crearemos la infraestructura necesaria para que las características que se implementarán posteriormente tengan una base sólida para crear dispositivos que extiendan a los actuadores y sensores, definidos a través de las clases abstractas \imp{Actuator} y \imp{Sensor}, además de extender a la propia clase \imp{Gateway}, añadiéndola nuevas funcionalidades y/o características a través del uso de las clases parciales.

Una parte importante del sistema son las interfaces gráficas que permitirán al usuario interactuar con el Gateway. Se implementan dos, la primera de ellas permite al usuario actuar con el Gateway, mientras que la segunda hará el papel de simulador, ya que es necesario modificar algunos valores que deberían ser alterados por elementos externos al propio sistema, tales como la temperatura actual de una habitación o el tiempo,ya que el sistema no se encuentra conectado a dispositivos reales.

No obstante, no se debe olvidar que se está implementado una línea de productos software, por lo que todos los diseños de las interfaces gráficas deben adaptarse a cualquier composición de características que haga un usuario.

Como punto de partida para el diseño de las interfaces gráficas se ha utilizado la API para el desarrollo de aplicaciones gráficas que incluye .NET, denominada \emph{Windows Forms}\cite{brown:2006}. Con esta API para construir una interfaz gráfica se deben añadir controles a una forma e implementar respuestas a las acciones de los usuarios, tales como un click de ratón o la pulsación de una tecla. Un control se define como una interfaz de usuario que muestra datos o acepta datos de entrada. Por lo que lo primero que se debe pensar es en los controles que serán más adecuados para la ventana que contiene la interfaz gráfica. Debido a que el número de plantas y el de habitaciones debe ser variable, la interfaz debe permitir cualquier cantidad de plantas o habitaciones, además el control elegido debe ser un contenedor para otros controles, ya que cuando una planta sea seleccionada se deben mostrar todas las habitaciones que contiene, y cada habitación debe de poder contener diferentes características (control de ventanas,persianas,luces...). Por todo lo citado anteriormente, se ha decidido utilizar un diseño como el mostrado en la figura \ref{domain:fig:gatewayGUI}, que se compone de un primer control con pestañas que contiene las plantas y que permitirá añadir nuevas características para su control global en toda la casa, el segundo control tiene todas las plantas mostradas por pestañas, y por último por cada pestaña específica de una planta existe otro control que contiene pestañas con las distintas habitaciones.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.55\linewidth]{domainEngineering/Images/GUI.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el Gateway}
 \label{domain:fig:gatewayGUI}
\end{figure}

Siguiendo el mismo razonamiento que anteriormente, se ha tenido que diseñar y elegir los controles que irán en la ventana del simulador. En el caso del sistema base,solo se encargará de mostrar las plantas y habitaciones que se han creado, por lo que se vuelve a seleccionar un control que permita añadir pestañas tal y como se muestra en la figura \ref{domain:fig:simulatorGUI} y una tabla con el identificador de una habitación, su nombre y la planta a la que pertenecen.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.65\linewidth]{domainEngineering/Images/simulatorGUI.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el simulador}
 \label{domain:fig:simulatorGUI}
\end{figure}

Para poder añadir nuevas funcionalidades y características a ambas interfaces gráficas se utilizan las clases parciales, de tal modo que cada vez que se crea una nueva característica, ésta extiende la clase que implementa la interfaz gráfica de usuario con nuevos controles, o modificando los actuales.

Una vez implementado todo el sistema base se han realizado una serie de test de prueba, que consisten en crear instancias del sistema para comprobar que tanto las plantas y habitaciones eran creadas, añadidas y mostradas correctamente.

Tras haber finalizado la implementación del sistema base ya se tiene la infraestructura básica para poder crear nuevas características que extiendan y añadan nuevas funcionalidades, por lo que la siguiente sección describe el proceso de desarrollo para la característica \emph{HeaterMng}.
\section{Iteración 2: HeaterMng}

%% Section{Iteración 2: HeaterMng}

%%% Requisitos específicos

%%% Diseño UML

%%% Diseño Interfaz Gráfica

%%% Implementación

%%% Pruebas
La característica manejo de calefacción o \emph{HeaterMng} en inglés, permite a los usuarios establecer un valor específico para la temperatura en grados Celsius tanto para un calefactor, como a nivel global en todos los calefactores. Los calefactores tienen la propiedad de ser aparatos de frío/calor, ya que su función es establecer los grados que determine el usuario, por lo que si la temperatura donde se encuentra es superior a la que establezca el usuario, el calefactor estará enfriando, en caso contrario estará calentando. Para la situación en la que la temperatura seleccionada por el usuario coincida con la temperatura del lugar donde se encuentra el calefactor, este último no entrará en modo funcionamiento, con lo que no consumirá energía.

Lo que debe hacer esta característica es volver a definir la clase parcial \imp{Gateway}, de este modo se pueden añadir nuevos métodos y atributos. Para definir los nuevos dispositivos se extienden las clases abstractas \imp{Actuator} y \imp{Sensor}. Estos nuevos dispositivos serán termómetro y calefactor, representados por las clases \imp{Thermometer} y \imp{HeaterCtrl} tal y como se ilustra en la figura \ref{domain:fig:heaterMngDesign}. Además cada calefactor debe tener asociado obligatoriamente un termómetro exclusivo, así las mediciones de las temperaturas serán mas precisas que si solo se utilizase un termómetro para toda la casa.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/HeaterMngDesign.eps} \\
 \caption{Diseño UML para la característica \emph{HeaterMng}}
 \label{domain:fig:heaterMngDesign}
\end{figure}

La principal acción que sostiene esta nueva característica es la de modificar la temperatura de los calefactores por los usuarios del sistema, por ello la figura \ref{domain:fig:secuenciaHeaterMng} ilustra a través de un diagrama de secuencia cuales son los pasos de los mensajes necesarios para que la temperatura sea modificada. Como ya se ha comentado en otras ocasiones en el diagrama de secuencia se vuelve a observar como el Gateway es el mediador que se encarga de transmitir los mensajes entre los distintos dispositivos.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/secuenciaHeaterMng.eps} \\
 \caption{Diagrama de secuencia para modificar la temperatura.}
 \label{domain:fig:secuenciaHeaterMng}
\end{figure}

A nivel gráfico también es necesario extender las dos interfaces gráficas de usuario que se implementaron en el sistema base, para ello se vuelven a definir las clases parciales para dichas interfaces. De este modo para el caso de la interfaz gráfica que representa al Gateway, es necesario añadir una nueva pestaña al primer control, que contiene la pestaña para plantas y que es el destinado a tener las diferentes pestañas para las distintas características en el ámbito global, en la que se añadirá un botón para encender o apagar todos los calefactores, y en el caso de que el botón esté en el estado de encendido se mostrará un campo para añadir la temperatura deseada a través del teclado, y una barra deslizante que también cumple con el mismo cometido de modificar la temperatura. Una nueva pestaña con el mismo diseño citado anteriormente es añadida al control que contiene las diferentes pestañas de las características de  una habitación que posea calefactores. Para ilustrar de un modo más claro esta descripción del diseño, se muestra la figura \ref{domain:fig:GUIHeaterMng}, en la que se puede observar en las dos capturas de la parte superior las dos pestañas que contienen los controles para la característica en modo global, es decir, si el botón de encendido/apagado es pulsado afectará a todos los calefactores de la casa, mientras que las dos capturas de la parte inferior afectan a un calefactor concreto de una habitación específica.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/GUIHeaterMng.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el Gateway en la característica de \emph{HeaterMng}}
 \label{domain:fig:GUIHeaterMng}
\end{figure}

Por otro parte se tiene que añadir nueva funcionalidad a la interfaz gráfica del simulador, por lo que nuevamente se definen las clases parciales para esta interfaz y se añade una nueva pestaña destinada a contener un control que muestre en formato tabla los diferentes calefactores con su identificador, habitación a la que pertenecen, planta, temperatura seleccionada, temperatura del termómetro, estado(encendido o apagado) y modo de funcionamiento(con consumo de energía o sin ella),además de un campo que permite introducir los grados deseados para modificar la temperatura de un termómetro, debido a que ningún termómetro está conectado a un dispositivo real, por lo que dicho valor es modificado manualmente. El resultado del diseño del simulador se ilustra en la figura \ref{domain:fig:SimulatorHeaterMng}

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/simulatorGUIHeaterMng.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el simulador en la característica de \emph{HeaterMng}}
 \label{domain:fig:SimulatorHeaterMng}
\end{figure}

Para llevar a cabo las pruebas sobre esta característica se han realizado una serie de test que han seguido el siguiente procedimiento:
\begin{enumerate}
\item Se han creado una serie de instancias del hogar inteligente con diferente número de calefactores repartidos por distintas habitaciones.
\item Por cada instancia se realizan los siguientes casos de prueba:
	\begin{enumerate}
		\item Se enciende,se apagan y se modifica la temperatura de todos los calefactores,a través de la pestaña de control global de la característica, en la interfaz gráfica del Gateway, y se comprueba a través del simulador y del propio Gateway que ha funcionado correctamente.
		\item Por cada calefactor se encenderá, se apagará y se modifica la temperatura,de modo individual a través de su pestaña específica.
		\item Por cada calefactor se modificará su temperatura para que coincida con la de su termómetro, comprobándose que el calefactor cambie su modo de funcionamiento a sin consumo de energía.
		\item Se modifica la temperatura de los termómetros y se comprueba que se modifica en el simulador.
		\item Por cada calefactor se modifica la temperatura de su termómetro para que coincida con la temperatura seleccionada en el calefactor y se comprueba que el modo de funcionamiento cambie.
	\end{enumerate}
\end{enumerate}

En la siguiente sección se describe el proceso para implementar la siguiente característica.

\section{Iteración 3: WindowMng}
%% Section{Iteración 3: WindowMng}

% Muy resumida

La característica manejo de ventanas o \emph{WindowMng} en inglés, tiene como principal requisito permitir a los usuarios abrir o cerrar una ventana con una determinada apertura. Por cada ventana existirán dos dispositivos, uno de ellos será un sensor que únicamente se encargará de enviar al Gateway la apertura que tiene la ventana, y otro será el actuador, que es el destinado a recibir la información del Gateway para abrir o cerrar con una determinada apertura.

Al igual que ha ocurrido en la característica descrita en la sección anterior, se vuelve a definir la clase parcial \imp{Gateway} para extender la funcionalidad necesaria para controlar y manejar las ventanas. Las clases abstractas \imp{Actuator} y \imp{Sensor} vuelven a ser extendidas con los dispositivos específicos para esta característica. La figura \ref{domain:fig:designWindowMng} ilustra el diseño UML que representa lo descrito anteriormente.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/WindowMngDesign.eps} \\
 \caption{Diseño UML para la característica \emph{WindowMng}.}
 \label{domain:fig:designWindowMng}
\end{figure}

Para el caso de las dos interfaces gráficas se ha seguido un proceso similar que el utilizado en la característica \emph{HeaterMng}, es decir, volviendo a definir las clases parciales que implementan a las interfaces gráficas se añaden nuevos controles del tipo pestaña. De este modo las interfaces muestran un diseño como el representado en la figura \ref{domain:fig:GUIWindowMng}, en la cual en la parte superior de la izquierda se ilustra la interfaz gráfica del Gateway con la pestaña global que controla todas las ventanas, mientras que en la parte superior de la derecha se ilustra el diseño destinado a controlar una ventana específica. En la parte inferior de la figura se muestra la interfaz gráfica para el simulador.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/GUIWindowMng.eps} \\
 \caption{Diseño de las interfaces gráficas para la característia \emph{WindowMng}}
 \label{domain:fig:GUIWindowMng}
\end{figure}

Para las pruebas en esta característica se han realizado una serie de test, que han seguido el siguiente procedimiento:
\begin{enumerate}
\item Se han creado una serie de instancias del hogar inteligente con diferente número de ventanas repartidas por distintas habitaciones.
\item Por cada instancia se realizan los siguientes casos de prueba:
	\begin{enumerate}
		\item Se modifica la apertura de las todas las ventanas, a través de la pestaña de control global de la característica, en la interfaz gráfica del Gateway, y se comprueba en el simulador y en el propio Gateway.
		\item Por cada ventana se modifica su apertura, de modo individual a través de su pestaña específica.
	\end{enumerate}
\end{enumerate}

La siguiente sección describe el proceso de desarrollo de la característica \emph{SmartEnergyMng},que necesitará de la existencia de la característica de la sección actual, como la de la anterior.

\section{Iteración 4: SmartEnergyMng}
%\label{sec:domain:smartEnergy}
%% Section{Iteración 4: SmartEnergyMng}

%%% Introducción justificando por qué

%%% Requisitos específicos (muy resumidos)

%%% Diseño UML

%%% Implementación (explicar como se ha conseguido **Hacerlo bien**)

%%% Pruebas
La característica denominada control de energía inteligente o \emph{SmartEnergyMng} en inglés,tiene como particularidad que necesita del control de ventanas (WindowMng) y del control de calefacción (HeaterMng) para que se puede utilizar, ya que su función es por un lado, que siempre que los calefactores estén encendidos se cierren todas las ventanas para evitar pérdidas de energía, y por otro lado, almacenar los horarios de los habitantes, de este modo siempre que la casa esté vacía los calefactores serán apagados para ahorrar energía y se encenderán con la suficiente antelación para poder restablecer la temperatura elegida por el usuario.

Al igual que todas las demás características descritas en las secciones anteriores, se redefine la clase parcial \imp{Gateway} tal y como se muestra en la figura XX, a través de ello se añaden varios métodos que permiten implementar los requisitos. En primer lugar para desarrollar el requisito que almacena los horarios de los habitantes se utiliza el metalenguaje de etiquetas XML \cite{rusty:2004}, a través de él se almacena en un fichero el nombre, apellidos y los intervalos de tiempo en el que no se encuentra en casa cada habitante. Con el método \imp{findEmptyTime()}, mostrado en la figura XX \todo{PONER FIGURA}, se realizan las operaciones oportunas para calcular los intervalos de tiempo en los que la casa estará vacía, los cuales serán utilizados por el otro método denominado \imp{checkTime(int hours, int minutes)} para comprobar, cada vez que el tiempo sea modificado, si la casa está vacía, y en ese caso desconectar todos los calefactores o encenderlos en el caso de que el tiempo se aproxime a la llegada de los usuarios.

El siguiente requisito que es necesario implementar es el encargado de cerrar las ventanas cuando los calefactores estén funcionando, por lo que se nos presenta una situación que no se puede resolver a través de las clases parciales, debido a que en la característica HeaterMng tenemos un método en la clase \imp{Gateway} para ajustar la temperatura de un calefactor a través del actuador correspondiente, y por lo tanto, es necesario redefinir este método que modifica la temperatura de los calefactores para cada vez que sea llamado se encargue de cerrar las ventanas. Pero esto no es algo trivial de realizar con las clases parciales, ya que no poseen la propiedad de extender métodos o sobrescribirles, únicamente separan una clase en diferentes archivos, para que luego el compilador los junte. Por lo tanto, se ha tenido que desarrollar una alternativa que supla esta carencia de las clases parciales, por lo cual se ha creado un mecanismo que sigue el siguiente proceso:
\begin{enumerate}
\item Todos los métodos de la clase parcial \imp{Gateway}, en todas las características, han sido renombrados usando el nombre de la característica como prefijo, por ejemplo el método denominado \imp{heaterAdjustTemperature} de la característica HeaterMng pasará a llamarse \imp{heaterMng\_heaterAdjustTemperature}. De este modo evitaremos que existan ambigüedades de nombres entre métodos de distintas características.
\item Se definen los métodos que presentasen ambigüedad si no hubiésemos realizado el paso anterior en otra definición de la clase parcial \imp{Gateway} destinada exclusivamente a contener este tipo de métodos. El nombre del método será sin el prefijo de ninguna característica.
\item Los métodos definidos en el paso anterior contendrán llamadas a los métodos correspondientes, dependiendo de la característica que sea seleccionada. Por ejemplo, para el método \imp{heaterAdjustTemperature}, si se ha seleccionado la característica SmartEnergyMng se deberá llamar al método \imp{smartEnergyMng\_heaterAdjustTemperature}.El código del método tendrá un aspecto como el mostrado en la figura \ref{domain:fig:codSmartEnergy}.
\item Todas las llamadas a los métodos que sean susceptibles de ambigüedad serán sobre los métodos correspondientes creados en el paso anterior.
\end{enumerate}

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 public void heaterAdjustTemperature(int id_heater, double temperature)
01 {
02      smartEnergyMng_heaterAdjustTemperature(id_heater, temperature);
03 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del método heaterAdjustTemperature cuando la característica SmartEnergyMng está seleccionada}
\label{domain:fig:codSmartEnergy}
\end{figure}
Siguiendo este proceso se ha conseguido solucionar el primer problema que ha surgido al trabajar con líneas de productos software mediante las clases parciales de C\#.

Nuevamente se necesita definir las interfaces gráficas para esta característica, para el caso de la interfaz que representa al Gateway, únicamente se añade una nueva pestaña global que contendrá un botón que activa o desactiva el control inteligente de energía y un campo que permite introducir la temperatura que se quiere tener cuando se reconecten los calefactores después de que la casa haya estado vacía. Mientras que la interfaz gráfica que representa al simulador, implementa una nueva pestaña para esta característica, en la que se puede modificar el tiempo del sistema, puesto que el sistema no funciona bajo una construcción real de una hogar inteligente, por lo que de este modo se podrá modificar el tiempo a nuestro antojo para facilitar las tareas de simulación. Por otro lado también se ha añadido una lista con los intervalos de tiempo en la que la casa se encuentra vacía, tal y como se ilustra en la figura \ref{domain:fig:SimulatorSmartEnergyMng}.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/simulatorGUISmartEnergyMng.eps} \\
 \caption{Diseño de la interfaz gráfica de usuario para el simulador en la característica de \emph{SmartEnergyMng}}
 \label{domain:fig:SimulatorSmartEnergyMng}
\end{figure}

Para realizar las pruebas correspondientes de esta característica se han dividido en varios tests, el primer de ellos es el encargado de verificar los métodos que se encargan de leer y encontrar en el fichero XML los horarios en los que la casa se encuentra vacía, para ello se ha modifica dicho fichero en varias ocasiones, en las cuales la mitad de las veces el número de habitantes era impar y en la otra mitad par, además de añadir de un modo aleatorio horarios a los habitantes, en los que al menos existiese un intervalo en el que la casa estuviese vacía en la mitad de las ocasiones.

Otro conjunto de tests son los destinados a comprobar que los calefactores se apagan y se encienden correctamente si la casa está vacía, por lo que nuevamente se utilizan los ficheros XML anteriores en los que la casa está vacía y se comprueba que si el control de energía inteligente está encendido se comporta correctamente. Por lo cual se crean una serie de instancias de la casa con diferente número de calefactores distribuidos por distintas habitaciones y se comprueba.

La última batería de tests es la encargada de comprobar que las ventanas son cerradas si el control de energía está encendido y alguno de los calefactores de la casa está encendido. Por lo tanto se crean diferentes estancias de la casa con distintas distribuciones de ventanas y calefactores en las habitaciones, y se comprueba que todas las ventanas son cerradas siempre y cuando se cumplan las dos condiciones anteriores.

La siguiente sección describirá brevemente las iteraciones restantes para terminar de implementar la ingeniería de domino de esta línea de productos software.


\section{Otras iteraciones}
%% Section{Otras iteraciones}

%% Muy resumido y destacando lo que te apetezca destacar
Como se ha podido observar en las iteraciones anteriores se sigue un procedimiento muy simular en todas ellas, ya que siempre se están utilizando las clases parciales como un mecanismo para añadir nueva funcionalidad a una clase existente.

En UML las características son agrupadas como paquetes. Un \emph{paquete} es definido en UML como un elemento de modelado usado para agrupar otros elementos de modelado, para de este modo obtener un espacio de nombres para los elementos agrupados.
La relación \emph{merge} entre dos paquetes, indica que el contenido de ambos es combinado, la especificación UML establece que esta relación se debe usar cuando los elementos de los paquetes tienen el mismo nombre y representan el mismo concepto\cite{omg:uml:2005}. Por lo que podemos definir un diagrama de paquetes como el mostrado en la figura \ref{domain:fig:packageDiagram}, en el que todas las características se conectan a través de una relación \emph{merge}. Por lo tanto, a través de la figura \ref{domain:fig:packageDiagram} se puede reflejar que todas las características realizan una combinación de sus elementos con el mismo nombre haciendo uso de las clases parciales.
\begin{figure}[!tb]
 \centering
 \includegraphics[width=.75\linewidth]{domainEngineering/Images/packageDiagram.eps} \\
 \caption{Diagrama de paquetes con todas las características.}
 \label{domain:fig:packageDiagram}
\end{figure}

Tras realizar todas las iteraciones necesarias para implementar la ingeniería de dominio, se consigue tener un sistema dividido que encapsula características que pueden ser combinadas y compiladas de diferentes maneras, siempre y cuando se respeten las restricciones básicas.

\section{Sumario}

En este capítulo se ha mostrado el proceso llevado a cabo para realizar la fase de ingeniería de dominio en esta línea de productos software, en la cual se han utilizado las clases parciales de C\# como principal mecanismo para encapsular las características. No obstante, las clases parciales presentan alguna limitación para encapsular correctamente, por lo que se han desarrollado y expuesto mecanismos para suplir estas limitaciones.

El siguiente capítulo mostrará como utilizando la infraestructura desarrollada anteriormente, se pueden crear aplicaciones específicas adaptadas a los requerimientos de los usuarios. 
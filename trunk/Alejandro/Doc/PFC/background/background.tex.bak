%=============================================================================%
% Author : Alejandro Pérez Ruiz                                               %
% Author : Pablo Sánchez Barreiro                                             %
% Version: 1.0, 07/03/2011                                                    %
% Master Thesis: Background, master file                                      %
%=============================================================================%
\chapterheader{Antecedentes}{Antecedentes}

\label{chap:background}

En este capítulo se ofrece una visión general de que son las líneas de productos software, cuales son sus principales objetivos y se realiza un análisis sobre las técnicas actuales existentes que se podrían utilizar para trabajar con las líneas de productos software con la ayuda de un problema concreto.

\chaptertoc

\section{Líneas de Productos Software}

% Explica que es una línea de productos software, objetivos y terminología

El objetivo de una línea de productos software~\cite{pohl:2005} es crear una infraestructura adecuada a partir de la cual se puedan derivar, tan automáticamente como sea posible, productos concretos pertenecientes a una familia de productos software. Una familia de productos software es un conjunto de aplicaciones software similares, que por tanto comparten una serie de características comunes, pero que también presentan variaciones entre ellos.

Un ejemplo clásico de familia de productos software es el software que se encuentra instalado por defecto en un teléfono móvil. Dicho software contiene una serie de facilidades comunes, tales como agenda, recepción de llamadas, envío de mensajes de texto, etc. No obstante, dependiendo de las capacidades y la gama del producto, éste puede presentar diversas funcionalidades opcionales, tales como envío de correos electrónicos, posibilidad de conectarse a Internet mediante red inalámbrica, radio, etc.

La idea de una línea de productos software es proporcionar una forma automatizada y sistemática de construir un producto concreto dentro de una familia de productos software mediante la simple especificación de qué características deseamos incluir dentro de dicho producto. Esto representa una alternativa al enfoque tradicional de desarrollo software, el cual se basaba simplemente en seleccionar el producto más parecido dentro de la familia al que queremos construir y adaptarlo manualmente.

El proceso de creación de líneas de producto software conlleva dos fases: \emph{ingeniería de dominio} (en inglés,  \emph{Domain Engineering}) e \emph{ingeniería de aplicación} (en inglés, \emph{Application Engineering}) (la figura~\ref{back:fig:domainAplicEng} ilustra el proceso para ambas fases). La \emph{ingeniería de dominio} tiene como objetivo la creación de la infraestructura o arquitectura de la línea de productos, la cual permitirá la rápida, o incluso automática, construcción del sistema software específico dentro de la familia de productos. La ingeniería de aplicación utiliza la infraestructura creada anteriormente para crear aplicaciones específicas adaptadas a las necesidades de los usuarios.

\begin{figure}[!tb]
  \centering
	\includegraphics[width=.95\linewidth]{background/images/domainAplicationEngineering.eps} \\
  \caption{Proceso de desarrollo de una línea de productos software}
  \label{back:fig:domainAplicEng}
\end{figure}

%HECHO \todo{Poner un párrafo de enlace con la sección siguiente}
Cuando se trabaja con líneas de productos software, los lenguajes de programación orientados a objetos resultan muchas veces insuficientes. Con objeto de paliar estas deficiencias, en los últimos años han ido surgiendo unos nuevos tipos de lenguajes denominados \emph{orientados a características}. La siguiente sección introduce los programación orientada a características para a continuación explicar sus ventajas con respecto a las técnicas tradicionales orientadas a objetos.

%% DONE


\section{Diagramas de características}
Un diagrama de características es la notación visual para un modelo de características, el cuál es básicamente un árbol and-or.

Las relaciones entre las características padres y las características hijas pueden ser clasificadas como:
\begin{enumerate}
\item \emph{Obligatoria}: La característica hija es obligatoria.
\item \emph{Opcional}: La característica hija es opcional.
\item \emph{Simple}: La característica hija tendrá cardinalidad \emph{<m..n>}
\item \emph{Grupo Or}: Al menos una de las características hijas debe ser seleccionada.
\item \emph{Grupo Xor}: Sólo una de las características hijas debe ser seleccionada
\item \emph{Grupo-Simple}: El número de características seleccionadas del grupo vendrá dado por su cardinalidad.
\end{enumerate}
Para representar visualmente las relaciones descritas anteriormente se utiliza la notación que se puede observar en la figura \ref{back:fig:not}.

\begin{figure}[!tb]
  \centering \includegraphics[width=.65\linewidth]{background/images/notFeatureDiagram.eps} \\
  \caption{Notaciones utilizadas en los diagramas de características}
  \label{back:fig:not}
\end{figure}

Además de las relaciones las características pueden tener restricciones, comúnmente las más utilizadas son requiere(si selecciona la característica A implica seleccionar la característica B) y excluye (si se selecciona la característica A la característica B debe ser excluida), pero puede ser utilizada cualquier fórmula lógica que describa una restricción.

El objetivo de este tipo de diagramas a parte de la propia representación y facilidad para visualizar las diferentes características, es la posibilidad de utilizar las transformaciones de modelos para conseguir realizar configuraciones que satisfagan las restricciones\cite{czarnecki:2004}.

A modo de ejemplo se incluye en la figura \ref{back:fig:featureModel} el diagrama de características para el \emph{problema de las expresiones} modelado anteriormente en los diferentes lenguajes.
\begin{figure}[!tb]
  \centering \includegraphics[width=.85\linewidth]{background/images/featureModelExpr.eps} \\
  \caption{Diagrama de características para el \emph{problema de las expresiones}}
  \label{back:fig:featureModel}
\end{figure}

\section{Programación Orientada a Características}

Los lenguajes orientados a características~\cite{prehofer:2001} tienen como objetivo encapsular conjuntos coherentes de funcionalidad de un sistema software en módulos independientes y fácilmente componibles de forma que se incremente la capacidad de reutilización y extensión de estos módulos. Dichos módulos reciben el nombre de \emph{característica}. Una característica se suele definir como un incremento de la funcionalidad de un sistema~\cite{batory:2004}.

Los lenguajes orientados a características son especialmente útiles en el contexto de las líneas de productos software, ya que nos permiten encapsular en módulos bien definidos las diferentes características, tanto comunes como variables, que pueden aparecer en cada uno de los productos software pertenecientes a una misma familia. Los lenguajes orientados a características tratan de facilitar además la composición de dichos módulos, contribuyendo así a que productos específicos dentro de una familia puedan ser creados mediante la simple composición o ensamblado de módulos software relativamente independientes.

Por ejemplo, a la hora de crear un tipo abstracto de datos pila, podemos considerar diferentes variaciones:
\begin{description}
\item[Básicas:]  Toda pila, para ser considerada pila, debe soportar las operaciones \imp{apilar} y \imp{desapilar}.
\item[Contador:] Añade un contador para conocer el tamaño de la pila.
\item[Bloqueo:] Permite bloquear la pila para evitar modificaciones en su estado.
\item[Deshacer:] Agrega la funcionalidad de restaurar el estado de la pila antes del último acceso a la misma.
\end{description}

El objetivo de la programación orientada a características sería encapsular cada una de las cuatro funcionalidades anteriores en módulos independientes y fácilmente componibles. De esta forma, se podrían obtener diferentes productos mediante la simple composición de conjuntos diferentes de características. Por ejemplo, un determinado usuario podría estar interesado en una pila con contador, por lo que compondría estas dos características y descartaría las demás. Otro usuario podría encontrar más adecuada una pila con bloqueo y deshacer, por lo que compondría estas tres características y dejaría fuera la correspondiente al contador.

Por lo tanto, un lenguaje orientado a características nos debe permitir descomponer fácilmente un programa en características, las cuales deberían encapsularse en módulos bien definidos y tan independientes como sea posible. A la hora de crear productos concretos, dichos módulos se compondrían de acuerdo a las necesidades de los usuarios.

La siguiente sección describe en mayor detalle los problemas que surgen cuando se intenta obtener un enfoque orientado a características usando un lenguaje de programación orientado a objetos.

%% DONE
\subsection{Limitaciones de la Orientación a Objetos frente a la Programación Orientada a Características}

Para analizar las limitaciones que posee la programación orientada a objetos a la hora de implementar líneas de productos software nos basaremos en un problema clásico de las líneas de productos, como es el \emph{problema de las
expresiones}~\cite{togersen:2004}. Dicho problema se describe a continuación.

%% DONE
\subsubsection{Descripción del Problema de las Expresiones}

El objetivo del problema de las expresiones es diseñar una aplicación software que para la gramática de la Figura~\ref{back:fig:gramExpr}, soporte las siguientes operaciones:

\begin{description}
	\item[Print:] Debe mostrar por consola la expresión en el formato correspondiente (infijo, prefijo o posfijo).
	\item[Eval:] Debe evaluar la expresión y retornar su resultado.
	\item[ShortEval:] debe evaluar la expresión realizando las operaciones \emph{cortocircuitadas}. Es decir, tan pronto como el valor de un operando determine el resultado de la expresión, se deberá parar la evaluación del resto de los operandos. Por ejemplo, en una multiplicación, si el primer operando es 0, se retornará el valor 0 directamente, sin evaluar el segundo operando.
\end{description}

\begin{figure}
\begin{center}
\begin{footnotesize}
\begin{verbatim}
Exp :: = Integer | AddInfix | MultInfix | AddPostfix | MulltPostfix |
				 AddPrefix | MultPrefix
Integer     :: <positive-negative integers>
AddInfix    ::= Exp "+" Exp
MultInfix   ::= Exp "*" Exp
AddPostfix  ::= Exp Exp "+"
MultPostfix ::= Exp Exp "*"
AddPrefix   ::= "+" Exp Exp
MultPrefix  ::= "*" Exp Exp
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Gramática del lenguaje de expresiones}
\label{back:fig:gramExpr}
\end{figure}

Identificamos en este problema dos conjuntos diferenciados de características: (1) las operaciones \imp{\{Print, Eval, ShortEval\}} que se pueden realizar sobre la gramática; y (2) si los operadores son infijos, prefijos o postfijos.
Por tanto, tenemos 6 características posibles para nuestros productos (operadores infijos, prefijos o postfijos, más \imp{\{Print, Eval, ShortEval\}} como operaciones opcionales para la gramática).

Por lo tanto, sería deseable implementar una línea de productos software que permita combinar las distintas operaciones y operadores de tal modo que por cada elección de elementos a combinar podamos obtener una aplicación software completa mediante la simple composición de los elementos seleccionados.

La siguiente subsección explica cómo se abordaría este objetivo usando orientación a objetos.

\subsubsection{Solución Orientada a Objetos}

\begin{figure}[!tb]
  \centering \includegraphics[width=.60\linewidth]{background/images/Expressions.eps} \\
  \caption{Diagrama de clases para las características comunes del problema de las expresiones}
  \label{back:fig:expr}
\end{figure}

\begin{figure}[!tb]
  \centering \includegraphics[width=.80\linewidth]{background/images/PrintInfix.eps} \\
  \caption{Diagrama de clases para las características comunes de impresión
  de operadores infijos}
  \label{back:fig:printInfix}
\end{figure}


La forma natural o tradicional de implementar características usando orientación a objetos es mediante herencia~\cite{gomma:2007,ziadi:2006}. Esta técnica se muestra en las Figuras~\ref{back:fig:expr} y~\ref{back:fig:printInfix}.

La Figura~\ref{back:fig:expr} muestra el diseño orientado a objetos de los elementos de la gramática. Usando este diseño, lo único que podríamos hacer es crear expresiones, compuestas por literales (\imp{Integer}s), combinados mediante operadores binarios (\imp{Add} y \imp{Mult}).

A continuación, por cada característica a implementar, lo que hacemos es extender estas clases mediante herencia añadiendo a cada clase las operaciones necesarias para implementar dicha característica. Por ejemplo, la Figura~\ref{back:fig:printInfix} muestra como se extienden las clases de la Figura~\ref{back:fig:expr} para que soporten la característica de operación infija.
Tal como muestra dicho diseño, lo que hacemos es por cada clase \imp{X} de la Figura~\ref{back:fig:expr}, creamos una nueva clase que herede de ella. A la nueva clase hija le damos el mismo nombre que a la padre, pero con \imp{Infix} como sufijo. A la clase hija le añadimos una operación \imp{print}, que contendría la funcionalidad necesaria para imprimir cada expresión, operador o literal de forma infija. Este proceso lo repetiríamos para el resto de características (e.g., impresión postfija, evaluación con cortocircuito), obteniendo por cada característica un diseño similar al de la Figura~\ref{back:fig:printInfix}.

Una vez diseñadas e implementadas la diferentes características del problema de las expresiones, el siguiente problema a solventar es cómo combinarlas de forma que podamos obtener de la forma más simple y rápida posible productos concretos con diferentes características. La técnica comúnmente empleada para componer características implementadas mediante herencia simple sería tal como se describe a continuación.

%%=============================================================================%
%% NOTA(Pablo): Sigue a partir de aquí
%%=============================================================================%
Para tratar de combinar las características deberíamos hacer uso de la herencia múltiple, ésta permite que una clase pueda heredar comportamientos y características de más de una superclase.
Pero por fortuna o por desgracia, la herencia múltiple entre clases ha ido desapareciendo poco a poco en los lenguajes de programación orientados a objetos actuales, tales como Java~\cite{arnold:2005} o C\#~\cite{albahari:2010}. Actualmente, la práctica general es permitir que una clase pueda heredar de una sola clase y de un número indeterminado de interfaces. Esto permite solventar los conocidos problemas de conflictos por colisión de comportamientos heredados, es decir, cuando un mismo método con dos implementaciones distintas está presente en clases padre diferentes. No obstante, en ausencia de este tipo de conflictos, la herencia múltiple es un mecanismo muy útil \cite{}, por lo que puede que su simple erradicación con el objetivo de evitar ciertas conflictos no sea una idea tan acertada como parece, cuya validez o no sólo conoceremos con el paso del tiempo y la experiencia.

No obstante, la solución para trabajar con herencia múltiple en lenguajes orientados a objetos con herencia simple, sería aplicar el \emph{patrón mixin}~\cite{david:1986}. De acuerdo con dicho patrón, que se ilustra en la Figura \ref{back:fig:mixin}, se utilizan las interfaces para simular la herencia múltiple. Por lo tanto, cada clase a heredar implementará una nueva interfaz que defina los métodos de esta clase, a su vez la nueva clase que se quiere crear para que herede la funcionalidad de sendas clases implementará las dos nuevas interfaces creadas anteriormente, y tendrá una relación de agregación con las clases a heredar.

\begin{figure}[!tb]
  \centering \includegraphics[width=.60\linewidth]{background/images/MixinPattern.eps} \\
  \caption{Diagrama de clases que hace uso del \emph{patrón mixin}}
  \label{back:fig:mixin}
\end{figure}

Pero por fortuna o por desgracia, la herencia múltiple entre clases ha ido desapareciendo poco a poco en los lenguajes de programación orientados a objetos actuales, tales como Java~\cite{arnold:2005} o C\#~\cite{albahari:2010}. Actualmente, la práctica general es permitir que una clase pueda heredar de una sola clase y de un número indeterminado de interfaces. Esto permite solventar los conocidos problemas de conflictos por colisión de comportamientos heredados, es decir, cuando un mismo método con dos implementaciones distintas está presente en clases padre diferentes. No obstante, en ausencia de este tipo de conflictos, la herencia múltiple puede ser un mecanismo muy útil~\cite{meyer:2000,meyer:2009}, por lo que puede que su simple erradicación con el objetivo de evitar ciertas conflictos no sea una idea tan acertada como parece, cuya validez o no sólo conoceremos con el paso del tiempo y la experiencia.

No obstante, la solución para trabajar con herencia múltiple en lenguajes orientados a objetos con herencia simple, sería aplicar el \emph{patrón mixin}~\cite{david:1986}. De acuerdo con dicho patrón, que se ilustra en la figura \ref{back:fig:mixin}, se utilizan las interfaces para simular la herencia múltiple. Por lo tanto, cada clase a heredar implementará una nueva interfaz que defina los métodos de esta clase, a su vez la nueva clase que se quiere crear para que herede la funcionalidad de sendas clases implementará las dos nuevas interfaces creadas anteriormente, y tendrá una relación de agregación con las clases a heredar.

Pero el uso del \emph{patrón mixin} hace que, un incremento de funcionalidad representado por un conjunto de nuevas subclases que heredan de un conjunto de clases superiores, no sea posible manejarlo como un solo módulo. La insuficiente encapsulación deriva en un incremento de la complejidad a la hora de configurar y construir nuevos productos por ensamblando o composición de características. Aún cuando las clases, separadas en paquetes, pertenezcan a una misma característica, es necesario seleccionar qué clases concretas van a ser usadas en un producto específico. Por ejemplo, para incluir la característica impresión infija para una configuración del problema de las expresiones es necesario seleccionar todos los operadores binarios(\imp{AddInfix} y \imp{MultInfix}) y literales (\imp{IntegerInfix}) que implementan la característica.

Otro problema es el manejo de las dependencias, ya que la herencia tradicional obliga a que las clases y subclases tengan diferentes nombres. Por lo tanto, las referencias a las clases concretas deben ser actualizadas. A mayor número de características en una línea de productos, las relaciones entre clases concretas se complican potencialmente, lo que resulta una situación indeseable. Esto incrementa la complejidad en las relaciones y dependencias entre clases.Por ejemplo, en la característica impresión infija no sería permitido una clase \imp{Add} o \imp{Mult}. Se tienen que crear dos clases concretas, que hereden de \imp{Add} y \imp{Mult}, con diferentes nombres, \imp{AddInfix} y \imp{MultInfix}. Esto incrementa la complejidad en las relaciones y dependencias entre clases.

\subsubsection{Conclusiones}

Tras analizar el problema con un lenguaje orientado a objetos como es C\# se podría determinar que sería deseable encontrar un nuevo paradigma de  programación, orientado a características,  donde se pudiesen obtener fácilmente diferentes versiones de una misma aplicación mediante la simple composición de características. Obviamente no todas las combinaciones de características serían válidas, por ejemplo para una característica de una aplicación para un hogar inteligente que se encargue de realizar un uso eficiente del consumo de energía a través del control de las perdidas por ventanas abiertas, necesitará que las características relacionadas con la calefacción y las ventanas estén seleccionadas. Por tanto, un lenguaje orientado a características debería asegurarse de que el resultado de la composición de un conjunto de características da lugar a aplicaciones válidas y consistentes.

A tenor de lo expuesto anteriormente, y siguiendo los estudios y trabajos realizados por \cite{lopez:2005,chul:2002,aracic:2006,chae:2009} se identifican una serie de elementos que sería deseable encontrar en un lenguaje orientado a características:

\paragraph{Extensibilidad a través de la adición y la sustitución:}

Como ya hemos comentado, una característica es normalmente considerada como un incremento en la funcionalidad de un sistema software~\cite{batory:2004}. Por lo tanto, los lenguajes orientados a características deberían  proporcionar mecanismos para añadir nuevas funcionalidades a las ya existentes dentro de un sistema. En los lenguajes orientados a objetos, la extensión se realiza a través de la herencia, pero como ya hemos expuesto, ésta sólo resulta adecuada cuando queremos extender la funcionalidad de una sola clase. No obstante, la implementación de una característica necesita extender varias clases al mismo tiempo.

Además la extensibilidad no siempre se realiza por adición, en ocasiones es necesario el uso de la sustitución. En los lenguajes orientados a objetos la sustitución se realiza mediante la  sobreescritura (\emph{overriding}, en inglés).

\paragraph{Encapsulación de características:}

Todas las extensiones pertenecientes a una característica concreta se deben añadir de una forma atómica. Por lo tanto, los lenguajes orientados a características deberían proveer de mecanismo para agrupar y encapsular los módulos pertenecientes a una misma característica. Por otra parte, estos módulos deberían poderse compilar independientemente.

\paragraph{Composición a nivel de característica:}

Productos específicos, o configuraciones de una descomposición orientada a características, son obtenidos por la selección y composición de unas características específicas. Por lo tanto, sería deseable que un lenguaje orientado a características tuviese construcciones del lenguaje para producir un producto en particular. Esto debería ser realizado a nivel de característica, especificando que características deberían ser incluidas, en lugar de tener que especificar los elementos individuales de cada característica.

\paragraph{Composición de características comprobando la coherencia:}

No todas las combinaciones de características son válidas. Por lo tanto, un lenguaje orientado a características debería detectar las restricciones, evitando así la implementación de configuraciones no válidas y manejar automáticamente las dependencias en la medida de lo posible.

La siguiente subsección describe como algunos de los lenguajes orientados a características actuales poseen algunas de las propiedades citadas anteriormente.

\subsection{Ventajas de los lenguajes orientados a características}
Los lenguajes orientados a características nos otorgan una mayor flexibilidad, ya que nos permiten que clases individuales puedan ser compuestas por un conjunto de características, por tanto son especialmente recomendados para utilizarlos con las líneas de producción software.

Para estudiar las ventajas de los lenguajes orientados a características se trabajará con CaesarJ \cite{aracic:2006} que es un lenguaje de programación basado en Java, que nos proporciona una mayor modularidad y el desarrollo a través de componentes reusables. Para ello trabaja con conceptos como clases y paquetes en una única entidad, llamada familia de clases, que constituye unidades de encapsulamiento adicional para agrupar clases relacionadas. Una familia de clases también es, en sí misma una clase. Así mismo, se introduce el concepto de clases virtuales, que son clases internas (de familias de clases) propensas a ser refinadas a nivel de subclases. En el refinamiento de una clase virtual, implícitamente se hereda de la clase que refina, por lo que también esto es visto como una relación adjunta. También, en un refinamiento pueden ser añadidos nuevos métodos, campos, relaciones de herencia y sobreescritura de métodos. Puesto que en cada familia de clases, las referencias a las clases virtuales siempre apuntarán al refinamiento más específico. Esto significa que, por medio de las clases virtuales se aplica sobre escritura de métodos, permitiendo redefinir el comportamiento de cualquier subclase de una familia de clases.

En términos de programación orientada a características, cada funcionalidad es modelada como una familia de clases. Mientras que los componentes y objetos del dominio específico, son correspondidos por sus clases virtuales. Así mismo, las clases virtuales pueden ser declaradas como clases abstractas, lo que habilita la definición de interfaces en la implementación modular de características.

Para hacer uso de lo citado anteriormente y ver su beneficio con las líneas de producción software se ha vuelto a utilizar el ya comentado problema de las expresiones de la subsección anterior. Pero en este caso, el diseño cambia significativamente debido a la características expuestas de CaesarJ.

Por un lado en la figura \ref{back:fig:caesarJExpressions} se muestra que por cada operación, tenemos una familia de clases, siendo la familia de clases que encapsula a todas las demás, la denominada \imp{Expressions}. Ésta tiene la estructura de clases representado en la figura \ref{back:fig:expr}, y cada familia de clases lo que hace es redefinir las clases virtuales de \imp{Expressions} con las operaciones necesarias en cada caso.

\begin{figure}[ht!]
  % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.60\linewidth]{background/images/CaesarJExpressions.eps} \\
  \caption{Diseño para resolver el problema de las expresiones con CaesarJ}
  \label{back:fig:caesarJExpressions}
\end{figure}
\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 import eval.Eval;
01 import printPostfix.PrintPostfix;
02 import printInfix.PrintInfix;
03 import printPrefix.PrintPrefix;
04 public cclass EvalInfix extends PrintPrefix & Eval {}
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Configuración que incluye las operaciones de evaluar e imprimir en formato infijo con CaesarJ}
\label{back:fig:codCaesarJ}
\end{figure}

Para realizar configuraciones, únicamente se tiene que crear una nueva clase que extienda a las características que se deseen.A modo de ejemplo,la figura \ref{back:fig:codCaesarJ} muestra el código necesario para crear una nueva configuración que contenga las operaciones de impresión en formato posfijo y evaluación de una expresión.Con todo esto, vemos como CaesarJ otorga un gran nivel de encapsulamiento y de reusabilidad de los componentes.

\section{Clases Parciales C\#}
Las clases parciales C\# \cite{albahari:2010} nos permiten dividir la implementación de una clase, estructura o interfaz en varios archivos de código fuente. Cada fragmento representa una parte de la funcionalidad global de la clase. Todos estos fragmentos se combinan en tiempo de compilación para crear una única clase, la cual contiene toda la funcionalidad especificada en las clases parciales. Por lo tanto,las clases parciales C\# pueden utilizarse como un mecanismo adecuado para implementar características, dado que cada incremento en funcionalidad para una clase se podría encapsular en una clase parcial separada.


Para poder ser compiladas y agrupadas en una sola clase, todas las clases parciales deben pertenecer al mismo espacio de nombres, poseer la misma visibilidad y deben ser declaradas con el indicador clave partial. En C\#, un espacio de nombre es simplemente empleado para agrupar clases relacionadas y evitar conflictos de nombres. Para especificar los archivos C\# que deben ser incluidos en una compilación, se emplea un documento XML que contiene información acerca del proyecto y que especifica que ficheros deben ser compilados para generar el proyecto. Por lo tanto, es posible incluir y excluir fácilmente la funcionalidad encapsulada dentro de una clase parcial simplemente añadiendo o eliminando dicha clase parcial de este fichero XML.

Para ilustrar lo dicho anteriormente, se ha vuelto a utilizar el problema de las expresiones implementándolo con clases parciales. La figura \ref{back:fig:partialClass} muestra como hemos excluido de la compilación la característica que representa la operación de imprimir una expresión en formato infijo.
Este mecanismo de clases parciales permite añadir o compartir funcionalidad entre un conjunto de clases que no precisan estar relacionadas mediante ningún tipo de relación jerárquica, tal como ocurre con la herencia.

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01    <itemgroup>
02    <!--Eval-->
03    <Compile Include="Eval\Add.cs" />
04    <Compile Include="Eval\IExpressionsEval.cs" />
05    <Compile Include="Eval\IExpressions.cs" />
06    <Compile Include="Eval\Integer.cs" />
07    <Compile Include="Eval\Mult.cs" />
08    <!--Infix-->
09    <!--<Compile Include="Infix\Add.cs" />
10    <Compile Include="Infix\IExpressionInfix.cs" />
11    <Compile Include="Infix\IExpressions.cs" />
12    <Compile Include="Infix\Integer.cs" />
13    <Compile Include="Infix\Mult.cs" />-->
14    ...
15    </itemgroup>
16    </Project>
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del archivo XML que guarda la información para la compilación}
\label{back:fig:partialClass}
\end{figure}

Por lo tanto, algunos autores \cite{laguna:2007} sostienen que, las clases parciales C\# representan una alternativa a la herencia múltiple para manejar variabilidad relacionada con programación orientada a características.

% Qué hace esto aquí

% Explicar que son brevemente, y ejemplo usando las expresiones

\section{Sumario}
Durante este capítulo se han relatado los conceptos necesarios para entender el ámbito del problema para la implementación de una línea de productos software. De este modo ha quedado reflejado que la mejor opción son los lenguajes orientados a características, ya que poseen facilidades para encapsular y componer las características, mientras que la mayoría de los lenguajes orientados a objetos no poseen herencia múltiple, lo que complica notablemente la tarea para crear configuraciones a través de la composición de características, aunque el lenguaje C\# contiene las clases parciales que pueden ser una alternativa a la herencia múltiple.

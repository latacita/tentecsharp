%%=================================================================%%
%% Author : Pérez Ruiz, Alejandro                                  %%
%% Author : Sánchez Barreiro. Pablo                                %%
%%                                                                 %%   
%% Version: 1.0, 16/03/2011                                        %%                                                                                    %% Version: 1.1, 20/06/2011                                        %%                                                                                    %%                                                                 %%   
%%                                                                 %%
%% Memoria del Proyecto Fin de Carrera                             %%
%% Capítulo Application Engineering, Archivo raíz                  %%
%%=================================================================%%

\chapterheader{Ingeniería de la Aplicación}{Ingeniería de Aplicación}
\label{chap:application}

Este capítulo se describe la fase de \emph{ingeniería de aplicación} (en inglés, \emph{Application Engineering}) para nuestra línea de productos software. Dentro de dicha fase, se detalla el proceso seguido para componer las características creadas en la fase de ingeniería del dominio (ver capítulo anterior). A continuación, se describe la infraestructura creada para poder componer características siguiendo este proceso de forma tan automática como sea posible.
Por último, se describen las acciones llevadas a cabos para realizar el despliegue de nuestro producto.

\chaptertoc

\section{Proceso de composición de características}

La \emph{ingeniería de aplicación} es el proceso en el cual, las aplicaciones concretas de una línea de productos se construyen a través de los artefactos creados en la fase de ingeniería de dominio~\cite{pohl:2005}. Estas aplicaciones concretas, que en principio se espera que sea un número suficientemente largo, compartirán los artefactos creados durante la fase de ingeniería del dominio (ver capítulo anterior). Por tanto, para evitar redundancias y replicación de código que puedan generar problemas de mantenimiento y evolución, la solución natural es encapsular el código creado durante la fase de ingeniería de dominio en una biblioteca o componente reutilizable accesible desde los proyectos de ingeniería de la aplicación.

%%============================================================================%%
%% NOTA(Pablo): Esto ya lo hemos comentado bastante a lo largo de la memoria  %%
%%              así que lo quitamos de este punto                             %%  %%============================================================================%%
%%
%% Los principales objetivos de la ingeniería de aplicación son: 
%%  alcanzar un nivel tan alto como sea posible de reutilizar los elementos 
%%  del dominio cuando se definan y desarrollen aplicaciones de la línea de 
%%  productos y  explotar la variabilidad y los elementos comunes de la línea 
%%  de productos software durante el desarrollo de aplicaciones. Por lo que 
%%  este capítulo presentará al lector el proceso seguido para conseguir
%%  reutilizar y componer los elementos creados en la fase de ingeniería de 
%%  dominio. De tal modo que se deriven tan automáticamente como sea posible 
%%  aplicaciones adaptadas a los diferentes requisitos de cada usuario. Además 
%%  se mostrarán cuales han sido los problemas y las soluciones adoptadas a la 
%%  hora de trabajar con el lenguaje C\#, sus clases parciales, y la 
%%  plataforma .NET.
%%
%% En el capítulo \ref{chap:domain} anterior describimos el proceso para crear 
%% la infraestructura necesaria de la que se puedan derivar configuraciones 
%% concretas durante la fase de ingeniería de aplicación (ver Capítulo
%% \ref{chap:background}). El objetivo de esta fase de ingeniería de 
%% aplicación es componer características de la forma más cómoda y automática 
%% posible.
%%
%%============================================================================%%

%%============================================================================%%
%% NOTA(Pablo): Esto lo he resumido            
%%============================================================================%%
%%
%%  las cuales compartirán dicha infraestructura común. Por tanto, deberíamos 
%%  intentar evitar tener que replicar esta infraestructura con objeto de 
%%  evitar redundancias y los típicos problemas asociados al código replicado.
%%  Por ejemplo, si replicásemos el código por cada producto concreto creado, 
%%  cualquier modificación que se realizase sobre la infraestructura, habría 
%%  que propagarla a todos estos productos. Este puede ser un serio problema 
%% a medida que el número de productos derivados crece.
%%
%%============================================================================%%

%%============================================================================%%
%% NOTA(Pablo): Esto lo he resumido
%%============================================================================%%
%%
%% Por tanto, la solución natural es encapsular el código creado durante la 
%% fase de ingeniería de dominio en una biblioteca o componente modificable 
%% que el usuario no pueda reutilizar. Esto no obstante, va a a generar una 
%% serie de problemas adicionales a la hora de componer características y que
%% comentamos a continuación.
%%
%%============================================================================%%

%%============================================================================%%
%% NOTA(Pablo): Hacer una figrua con un diagrama de paquetes                  %%
%%              si se puede mostrar el contenido de HeaterMng y               %%
%%              SmartEnergyMng, mejor que mejor                               %% %%              Haz que el paquete representando la característica concreta   %%
%%              se llame MyHome                                               %%
%%============================================================================%%

De acuerdo a la filosofía del lenguaje CaesarJ~\cite{aracic:2006}, para 
crear una configuración concreta, deberemos crear una nueva característica 
que represente al producto final y que herede de las características
seleccionadas. Por ejemplo, la Figura~\ref{} muestra un ejemplo de un hogar
inteligente para el cual se ha seleccionado el control inteligente de 
energía, pero nada relacionado con el control automático de persianas ni 
de luces.

Siguiendo el patrón descrito en la sección~\ref{domain:sec:pattern}, deberemos crear una clase parcial por cada clase distinta contenida en una característica seleccionada. Las clases contenidas en la familia de clases representando el producto específico deberán contener un método por cada método distinto (sin considerar el prefijo del nombre que indica la característica a la cual pertenece). Por último, cada método deberá delegar en la versión correspondiente a la versión más profunda de dicho método en el árbol de herencia entre familias de clases.

Por ejemplo, de acuerdo con la Figura~\ref{}, en la característica \imp{MyProduct} deberíamos crear una clase parcial \imp{Gateway}; añadirle un método \imp{adjustTemperature}; y hacer que dicho método delegue en la versión de dicho método para la característica \imp{HeaterMng}, cuyo nombre, de acuerdo con el patrón de la Sección~\ref{domain:sec:pattern}, debe ser \imp{heaterMng\_adjustTemperature}. 

%%============================================================================%%
%% NOTA(Pablo): Simplificado                                                  %%
%%============================================================================%%
%%
%% Antes de comentar dichos problemas, recordar que uno de los requisitos 
%% principales de este proyecto es que tenía que funcionar en el lenguaje 
%% C\# de la plataforma .NET, y más concretamente, dentro del entorno Visual
%% Studio\cite{randolph:2010}. Esto va a a introducir una complejidad 
%% adicional en el proceso de composición de características que comentamos a
%% continuación, con ayuda de un ejemplo concreto.
%%
%%============================================================================%%

No obstante, este esquema, debido a las peculiaridades del compilador de C\#, no va a ser tan fácil de aplicar tal como se ha descrito. Tal como se ha comentado anteriormente, los artefactos creados en la fase de la ingeniería del dominio y los artefactos creados en la fase de ingeniería de la aplicación, se van a mantener en proyectos separados. El principal problema derivado de este esquema es que el compilador de C\# no es capaz de fusionar clases parciales creadas en proyectos diferentes. Por tanto, el esquema propuesto por el patrón de la sección~\ref{domain:sec:pattern} no es directamente aplicable tal como se ha descrito. 

Por tanto, hemos de decidir si modificar el patrón o renunciar a tener los artefactos pertenecientes a la fase de ingeniería del dominio o ingeniería de la aplicación separados. En aras de una mejor evolución y facilidad de mantenimiento de nuestra línea de productos software, optamos por modificar el patrón.

%%============================================================================%%
%% NOTA(Pablo): A este párrafo no le encuentro sentido del todo        
%%============================================================================%%
%%
%% Cuando se intenta crear una composición de características para un hogar  
%% inteligente en el que deseamos que aparezca el control inteligente de 
%% energía, obligatoriamente, debemos seleccionar el control de los 
%% calefactores y de las ventanas (ver Sección \ref{}). Además el método que 
%% se encargaba de ajustar la temperatura de un calefactor tenía una doble 
%% implementación, por un lado la característica control de calefactores tenía
%% una implementación del método básica, donde simplemente se establecía la 
%% temperatura deseada, mientras que en la característica control de energía 
%% inteligente se establecía la temperatura y se cerraban las ventanas para 
%% que no existiesen pérdidas.
%%
%%============================================================================%%

%%============================================================================%%
%% NOTA(Pablo): El hilo argumental es farragoso                
%%============================================================================%%
%% 
%% Esto obliga a solventar dos problemas, por un lado impedir que el usuario 
%% haga configuraciones incorrectas (esto será resuelto en el siguiente 
%% Capítulo\ref{}) y conseguir extender la funcionalidad de las clases 
%% parciales desde el componente que representé a la fase actual. Por lo 
%% tanto la primera pregunta que debemos resolver es: ¿Cómo encapsular y
%% relacionar el código de la fase de Ingeniería del Dominio con el 
%% desarrollado en la fase de Ingeniería de Producto? La plataforma .NET y el 
%% entorno Visual Studio proporcionan la capacidad de crear soluciones en la 
%% que pueden aparecer varios proyectos, por lo que se crearán dos proyectos en
%%  una misma solución. El primer proyecto contendrá el código creado en la 
%% fase de ingeniería de dominio, mientras que el segundo proyecto contendrá 
%% todos los artefactos necesarios para la fase de ingeniería de aplicación. 
%% Este último proyecto tendrá acceso al código del otro proyecto a través de 
%% la definición de una referencia, que permite que un proyecto tenga la 
%% posibilidad de usar un espacio de nombres perteneciente a otro proyecto. 
%% La siguiente cuestión es ¿Cómo extender la funcionalidad de determinadas
%% clases parciales cuando se realiza una configuración concreta? Como primera
%% respuesta a esta pregunta se trató de definir la clase parcial que se quería
%% extender en el proyecto destinado a la Ingeniería del Producto, pero esto no
%% es posible, ya que, el compilador no considera que ambas clases parciales 
%% son la misma, sino que trata de compilarlas por separado, por lo que esto
%% provoca un conflicto de ambigüedad.
%%
%%============================================================================%%

El procedimiento seguido para modificar el patrón se describe a continuación:

\paragraph{Paso 1: Redefinición de las clases existentes}

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 using SmartHome;
01 namespace MyHome
02 {
03  class MyHome_Room : Room
04    {
05        public MyHome_Room(String name, int id)
06            : base(name, id) { }
07    } // MyHome_Room
08 } MyHome
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Código para la clase \imp{MyHome\_Room} en la ingeniería de aplicación.}
\label{application:fig:room}
\end{figure}

Por cada clase distinta contenida en al menos una característica seleccionada, creamos una nueva clase en la característica correspondiente al producto concreto que está siendo creado. Dicha clase se llamará igual que su correspondiente clase en la fase de ingeniería del dominio, pero precedida por el nombre de la característica que representa al producto concreto. Esta nueva clase heredará de su correspondiente versión en la fase de ingeniería del dominio.

La Figura~\ref{application:fig:room} muestra como ejemplo el resultado de aplicar este procedimiento a la clase \imp{Room},que pertenece a la característica \imp{BaseSystem}.

\paragraph{Paso 2: Asegurar que cada clase satisface la interfaz adecuada}

De acuerdo con el patrón de la Figura~\ref{domain:sec:pattern}, las clases que representan el producto concreto deben contener un método por cada método distinto existente en las características seleccionadas. El nombre de dicho método no debe estar precedido por el nombre de ninguna característica. A esta versión de un método la denominaremos la versión \emph{limpia}. Por contraposición, la versión precedida por el nombre de la característica que lo contiene será la versión \emph{sucia}. 

Según el mencionado patrón, la versión limpia de cada método debe delegar en la versión sucia del mismo correspondiente a la característica seleccionada que esté situada más profundamente en el árbol de herencia entre características.

Al modificar el patrón de acuerdo al punto anterior, las clases de la ingeniería del dominio carecerán entonces de las versiones limpias de sus métodos. Por ejemplo, las clases que interaccionan con el \imp{Gateway} esperan que esta clase contenga un método \imp{adjustTemperature}, tal como aparece en los diseños de las características \imp{HeaterMng}  y \imp{SmartEnergyMng} (ver Figuras~\ref{domain:fig:heaterMngDesign} y~\ref{domain:fig:smartDesign}). 

El problema que nos encontramos ahora es que la clase que añade la versión  \emph{limpia} de cada método, es decir, la clase que compone las características seleccionadas, no es una clase parcial que se fusione con las clases creadas en la ingeniería del dominio. Esta clase ahora \emph{hereda} de su correspondiente versión en la fase de ingeniería del dominio. Por tanto, las clases creadas en la fase de la ingeniería del dominio carecerán de las versiones limpias de los métodos que deben implementar. 

Por ejemplo, la clase \imp{Gateway} de la fase de ingeniería del dominio carecerá del método \imp{adjustTemperature}, ya que éste ahora no se proporciona desde la fase de ingeniería de la aplicación al no ser la versión en ingeniería de la aplicación de la clase \imp{Gateway} una clase parcial que se fusione con las clases parciales \imp{Gateway} de la ingeniería del dominio. Por tanto, el compilador reportará el correspondiente error indicando que el método \imp{adjustTemperature} para la clase \imp{Gateway} no existe.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01 namespace SmartHome
02 {
03    partial class Gateway 
04    {
05        public virtual void adjustTemperature (int id, double temperature)
06        {
07            this.heaterMng_adjustTemperature(id, temperature);
08        }  // adjustTemperature
09
10        protected virtual void heaterMng_adjustTemperature(int id, 
11                                                  double temperature) {
12        ... } // heaterMng_adjustTemperature 
13    } // Gateway
14 } // SmartHome
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del método \imp{adjustTemperature} en la fase de ingeniería del dominio}
\label{application:fig:gateway}
\end{figure}


La solución es añadir los métodos limpios a la clase \imp{Gateway} de la fase de ingeniería del dominio. A estos métodos limpios definidos en la fase de la ingeniería del dominio los denominaremos \emph{método semi limpio}. Nos quedan dos problemas por resolver: (1) en que clase parcial se añaden la versión semi limpia de un método; y (2) que implementación se les da a estas versiones semi limpias.

La respuesta a la primera pregunta es que estos métodos deben aparecer en cuanto se les necesita. Es decir, la versión limpia de un método se crea en la característica que contenga a dicho método y que está situada a un nivel menos profundo dentro del árbol de herencia entre características. 

En el caso de la segunda pregunta, hay que tener en cuenta que la implementación de este método sólo se podrá conocer cuando se hayan seleccionado las características que se desean incluir en un producto concreto. Esto significa que un método semi limpio deberá ser sobreescrito cuando se cree un producto concreto. Por tanto, las versiones semi limpias de cada método se declaran como \emph{virtuales} con objeto de que puedan ser sobreescritos de forma efectiva en la fase de ingeniería de la aplicación, conforme al conjunto de características seleccionadas.

Por tanto, la implementación que le demos a estos métodos semi limpios será irrelevante, pues van a ser sobreescritos en la fase de ingeniería de la aplicación. Por tanto, optamos por dar a estos métodos semi limpios la implementación más simple posible que nos permita compilar la clase que los contiene. Esta implementación, en nuestro caso, se tratará de una simple delegación en la versión sucia del mismo método correspondiente a la característica donde se encuentra la versión semilimpia del mismo.

La Figura~\ref{application:fig:gateway} muestra el resultado de aplicar este paso al método \imp{adjustTemperature} dentro de la característica \imp{HeaterMng}. Destacar que las características que redefinan el método \imp{adjustTemperature} sólo contendrán la versión sucia de dicho método, dado que la versión limpia del mismo sólo puede aparecer en una única clase parcial de las muchas que implementan el \imp{Gateway}.

\paragraph{Paso 3: Selección de la implementación adecuada de cada método}

% Por aquí


Para permitir la redefinición de estos métodos, y de acuerdos con el patrón diseñado en este proyecto (cf. Sección~\ref{domain:sec:pattern}), se crearían las versiones de los métodos \imp{heaterMng_adjustTemperature}, \imp{smartEnergy_adjustTemperature} y \imp{adjustTemperature}, que delegaría en la implementación del método seleccionada. Este último método, de acuerdo con el mencionado patrón, se crearía en la fase de ingeniería de la aplicación, en tiempo de composición de características.


\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00  public override void adjustTemperature(int id, double temperature)
01  {
02     super.smartEnergy_adjustTempertature(id,temperature);
03  }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del método \imp{adjustTemperature} a nivel de ingeniería de la aplicación}
\label{application:fig:virtualMethods}
\end{figure}


%%============================================================================%%
%% NOTA(Pablo): El hilo argumental es farragoso
%%============================================================================%%
%%
%% Los métodos que su implementación dependa de la característica
%% seleccionada (ver el Capítulo \ref{chap:domain}), son definidos como
%% \emph{virtual}, para que puedan ser sobrescritos e implementados cuando
%% sean heredados en el proyecto que es implementado para la ingeniería de
%% aplicación.
%%
%%============================================================================%%

A modo de ejemplo, la Figura~\ref{application:fig:virtualMethods} muestra la implementación del método \imp{adjustTemperature} siguiendo el procedimiento descrito.

En el proyecto de la fase de ingeniería de aplicación se sobrescriben los métodos heredados necesarios del punto anterior, por ejemplo en la figura \ref{application:fig:gateway} se ilustra el código de la clase parcial \imp{Gateway} cuando se ha seleccionado la característica control inteligente de energía (SmartEnergyMng), por lo que el método \imp{heaterAdjustTemperature} deberá utilizar la implementación del método que se encuentra en la característica SmartEnergyMng.


\item Crear un método \imp{Main} que instancie y utilice las clases desarrolladas durante los pasos previos.
\end{enumerate}

Con esto procedimiento se consiguen componer características sin modificar el código de la ingeniería de dominio, con lo que se evitan los problemas de replicación de código mencionados anteriormente. Pero con esto no se consigue automatizar el proceso para derivar productos concretos, únicamente se obtiene un mecanismo que necesita aplicarse manualmente, ya que por un lado es necesario heredar de las clases que correspondan según la características seleccionadas. Por ejemplo, si la característica HeaterMng no se selecciona, las clases \imp{HeaterCtrl} y \imp{Thermometer} no deben ser heredadas e implementadas en la fase de ingeniería de aplicación. Y por otro lado se necesita implementar algunos métodos en función de las características elegidas, tal y como se comentó en el proceso descrito con anterioridad.

Por lo tanto, las siguientes secciones describen las partes del puzzle que son requeridas para completar la automatización en la composición de características. Concretamente la siguiente sección ilustra como se ha definido un metamodelo para que a partir de él se puedan crear modelos que no incumplan ninguna de las restricciones.
\section{Metamodelo y modelos}
Tras haber desarrollado un procedimiento para componer características en la sección anterior, ahora se necesita obtener un metamodelo. Un metamodelo es un modelo que define el lenguaje para expresar un modelo \cite{kleppe:2008}. Los metamodelos son complementados por procesos y/o restricciones que validan que los modelos no sean violados cuando se creen, modifiquen o eliminen datos.

Con la ayuda de un metamodelo que defina modelos de una la línea de productos software para hogares inteligentes, se podrá automatizar el proceso de composición de características. De este modo, por una parte se consigue evitar que el usuario realice configuraciones incorrectas, ya que los metamodelos contienen restricciones para evitar modelos inválidos. Y por otro lado, se consigue que la composición sea más cómoda y abstracta, debido a que los usuarios no deben conocer todos los detalles de la implementación que subyace.

El entorno de desarrollo Visual Studio contiene una serie de herramientas, denominadas \emph{Domain-Specific Language Tools (DSL Tools)} \cite{jones:2011}, que permiten crear herramientas basadas en el desarrollo por modelos que posteriormente podrán ser integradas en el propio entorno de Visual Studio.
La principal característica de DSL Tools es la definición de metamodelos para representar un concepto, como por ejemplo un hogar inteligente. Este metamodelo puede rodearse de una gran variedad de herramientas, tales como vista en diagramas, la posibilidad de generar código u otros artefactos, comandos para transformaciones y la posibilidad de interactuar con código y otros objetos en Visual Studio.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.65\linewidth]{applicationEngineering/images/metaModel.eps} \\
 \caption{Metamodelo para un hogar inteligente}
 \label{app:fig:metamodel}
\end{figure}


Por lo tanto, el propio Visual Studio integra las herramientas para automatizar todo el proceso de composición de características. De este modo, en primera instancia se diseña el metamodelo (ver figura \ref{app:fig:metamodel}) que nos permita definir modelos para un hogar inteligente. Posteriormente el metamodelo es trasladado a Visual Studio y se le asigna una notación específica. Pero el metamodelo no es completo porque algunas restricciones no están añadidas. Las restricciones que implícitamente aparecen en el metamodelo son las relacionadas con la cardinalidad, por ejemplo, siempre es necesario añadir una planta al hogar inteligente. Pero algunas como la C1, C2 y C3, que aparecen en la figura \ref{app:fig:metamodel} deben ser definidas explícitamente mediante código para que sean validadas.

De esta manera se consigue integrar en el propio entorno una nueva herramienta que permite construir modelos específicos y que evita que los usuarios creen configuraciones incorrectos. Por lo que también se puede decir que se ha abstraído el proceso para la composición de características, aunque con una herramienta que nos permita crear modelos no se completa el puzzle, ya que los modelos deben ser utilizados para que a partir de ellos se obtenga el código para la composición de las características. Por ello, la siguiente sección describirá como las plantillas de generación de código son utilizadas para este cometido.


\section{Plantillas de generación de código}
%% Section{Metamodelo y Modelo}
Las plantillas de generación de código \emph{T4 Text Templates} \cite{vogel:2010} son una forma rápida y sencilla de construir código a través de bloques de texto y código escrito en lenguaje C\# o VB. Este tipo de plantillas se introdujeron con Visual Studio 2005, y son una solución muy adecuada para el presente proyecto porque se encuentran integradas en el propio entorno de Visual Studio, por lo que otras alternativas como MOFScript \cite{oldevik:2005}, que es un lenguaje de transformación de modelo a texto basado en estándares de la OMG y desarrollado como un plugin para Eclipse, se desestimaron.

La sintaxis para crear plantillas es sencilla, en la figura \ref{application:fig:t4template} se ilustra un pequeño ejemplo en el que aparece como se deben usar. Por un lado, en la línea 00 se describe una directiva de ensamblado que indica que los bloques de código para esta plantilla serán escritos en C\#, y por otro lado en la siguiente línea se ilustra como los bloques de código que se quieren ejecutar deben de encontrarse delimitados por los siguientes caracteres: <\# \#>. Además existe la posibilidad de que se quiera mostrar el valor de una variable que se ejecuta en un bloque de código, por lo que sería necesario envolver la variable entre los caracteres <\#= \#>, tal y como se muestra en la línea 2 de la figura.

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 <#@ template language="C#" #>
01 Hello <# Write("World!"); #>
02 Today is <#= DateTime.Now.ToString() #>
\end{verbatim}
\end{footnotesize}
\caption{Ejemplo de uso de las plantillas T4}
\label{application:fig:t4template}
\end{center}
\end{figure}


Por lo tanto, se tiene un metamodelo que nos permite crear modelos que no violen las restricciones, por lo que a través de las plantillas de generación de código, se obtendrá el código correspondiente con el modelo creado por el usuario, para componer las características. Para ello es necesario hacer uso de la clase \imp{ModelingTextTransformation}, la cual permite acceder a las clases, propiedades y relaciones disponibles en un modelo.

Teniendo el acceso a las propiedades del modelo, se genera la clase que contiene el método \imp{Main} que instancia todos los componentes del hogar inteligente, además de las clases que definen los dispositivos y aquellas que tenían métodos virtuales cuya implementación dependía de las características que fuesen seleccionadas (ver Sección \todo{PONER SECCIÓN}). Por ejemplo, si se crea un modelo en el que solo existe el control de los calefactores, las clases para los dispositivos como \imp{WindowCtrl}, \imp{WindowSensor}, \imp{LightCtrl}... no son necesarias, por lo que las plantillas de generación de código no las crearán.

Cabe recordar que en el entorno de desarrollo existen dos proyectos, uno que contiene la infraestructura desarrollada durante la fase de ingeniería de dominio y otro que contiene todos los artefactos creados durante la fase actual. Por lo que en el proyecto desarrollado durante la fase de ingeniería de dominio se encuentran todas las características encapsuladas mediante las clases parciales. Y como ya se comentó (ver Sección \todo{PONER SECCIÓN}) los proyectos poseen un fichero escrito en XML donde se almacenan los elementos que serán compilados. Por lo que cuando se deriven productos es necesario indicar que elementos serán compilados, para evitar que características que no estén seleccionadas para la configuración actual se compilen, de tal modo que se gane en eficiencia y seguridad. En primera instancia, se contempló y probó la posibilidad de sobreescribir el fichero XML mediante las plantillas T4, pero el resultado no fue el esperado, debido a que el fichero XML es usado por la solución donde se encuentran los dos proyectos, es necesario reabrir la solución actual para que el fichero XML de compilación se cargue adecuadamente. Así que por ello, desde las propias plantillas T4 se debe indicar que elementos incluir o excluir de el proyecto para la compilación. Para tal cometido existe una
una librería denominada \imp{EnvDTE}, la cual contiene métodos para instanciar/automátizar el propio entorno de desarrollo de Visual Studio. Por lo que a través de un bloque de código de las plantillas T4 se utiliza la libería \imp{EnvDTE} para indicar que elementos deben estar excluidos o incluidos dentro del proyecto de la fase de ingeniería de dominio, para que de este modo solo se compilen las características seleccionadas.

De algún modo es necesario que los elementos creados hasta este momento sean encapsulados como plugins para el entorno Visual Studio, y puedan ser utilizados en cualquier computadora que tenga instalada una versión del entorno de desarrollo. Por lo que la siguiente sección describe el proceso seguido para crear los instaladores y su despliegue.
%%% Muy breve
\section{Instaladores y despliegue}
%% Section{Instaladores y Despliegue}

Es necesario que todos los artefactos creados hasta este punto sean empaquetados en plugins para que puedan extender la funcionalidad del entorno de desarrollo Visual Studio, sean distribuidos y se puedan instalar en cualquier ordenador. Para tal cometido, en primer lugar se crea un instalador que permita crear modelos de un hogar inteligente, el cuál ha sido desarrollado en la Sección \todo{PONER SECCIÓN}. De tal modo que se construye un archivo con extensión \emph{MSI (Windows Installer)}, que permite ser instalado en cualquier ordenador que posea la versión Professional 2010 del entorno Visual Studio. Lo que hace este instalador es añadir un nuevo elemento a Visual Studio, para poder crear en cualquier proyecto, un archivo que permita definir modelos de un hogar inteligente a través del metamodelo definido en la Sección \todo{PONER SECCIÓN}.

El segundo instalador permitirá a los usuarios añadir un nuevo plugin en Visual Studio que agregue una nueva solución a Visual Studio, la cual contendrá los dos proyectos creados en la fase de ingeniería de aplicación y de dominio. De tal modo, que instalando este plugin cualquier usuario podrá definir en su computadora su propia aplicación para un hogar inteligente. Debido a ciertos detalles técnicos de bajo nivel, que se omiten en aras de la brevedad y evitar aburrir al lector, el desarrollo de este instalador llevó un tiempo bastante mayor del inicialmente planeado. Su desarrollo supuso un esfuerzo extra, contrastando con el otro instalador, que requirió menor cantidad de tiempo. El principal problema se derivaba de la incapacidad de que ambos proyectos mantuviesen correctamente las referencias entre ellos cuando eran integrados como un nuevo plugin.

Ambos instaladores estarán disponibles a través de una página web, realizada con el único objetivo de dar a conocer el presente proyecto. Dicha web tendrá 5 secciones, que son descritas a continuación:
\begin{enumerate}
\item \emph{Introducción: }Contendrá un breve resumen para mostrar y presentar cual es el ámbito y los objetivos del proyecto.
\item \emph{Descargas: }En esta sección estarán disponibles los instaladores creados.
\item \emph{Documentación: }Mostrará toda la documentación relacionada con el proyecto.
\item \emph{Publicaciones: }Contendrá todas las publicaciones referentes al proyecto.
\item \emph{Contacto: }Sección para poder contactar con los creadores del proyecto.
\end{enumerate}


\section{Sumario}
Este capítulo ha mostrado los distintos pasos necesarios para realizar la composición de características en la plataforma .NET a través del lenguaje C\# y sus clases parciales. El primero de los pasos ha consistido en encontrar una modo de encapsular de forma separada el código creado en las fases de ingeniería de aplicación y dominio, para permitir derivar un número largo de aplicaciones concretas. Para tal cometido ha sido necesario desarrollar un mecanismo que supliese las carencias que existen en la plataforma .NET. En segunda instancia se ha desarrollado un metamodelo que permita crear modelos de un hogar inteligente, para que los usuarios pueden realizar configuraciones abstrayéndose de la implementación que subyace y evitar que se creen configuraciones que no sean válidas. A continuación, para completar la automatización, se presentan las plantillas de generación de código, que a través de los modelos que cree el usuario, obtendrán el código necesario para componer las características. Por último, se expone el proceso seguido para construir los instaladores que permiten distribuir todo el software creado hasta este momento y una página web usada como mecanismo de despliegue. 
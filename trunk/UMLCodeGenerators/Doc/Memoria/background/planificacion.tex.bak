%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 18/06/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Background/Generación de Código con Epsilon                      %%
%===================================================================%%

Como se ha comentado con anterioridad, el objetivo de este Proyecto Fin de Carrera era el desarrollar una serie de generadores de código que permitan automatizar la aplicación del \emph{Slicer Pattern}. Este patrón se utiliza para la desarrollo de  líneas de producto software, en las cuales se distinguen claramente, tal como se ha comentado dos fases: \emph{Ingeniería del Dominio}, e \emph{Ingeniería de Aplicaciones} (ver Figura~\ref{back:fig:domainAplicEng}).

Por tanto, el proceso de desarrollo del presente proyecto queda gobernado por dichas fases. La Figura~\ref{fig:planning} muestra dicho proceso de desarrollo.

\begin{figure}[!tb]
    \includegraphics[width=.95\linewidth]{background/images/planning.eps}
    \caption{Proceso de desarrollo del Proyecto Fin de Carrera}
    \label{fig:planning}
\end{figure}

Obviamente, la primera tarea (Figura~\ref{fig:planning}, \emph{T1A}), nada desdeñable, fue la de adquirir los conocimientos teóricos necesarios para la realización de todas las tareas posteriores. Ello implicaba adquirir los conocimientos relacionados con las \emph{Líneas de Producto Software}~\citep{pohl:2010, kakola:2006} en general; y con el diseño orientado a modelos~\citep{kastner:2008}, las clases parciales~\citep{sanchez:2010} y el \emph{Slicer Pattern}~\cite{perez:2011} en particular.

Dado que el proyecto se debía implementar con una herramienta para el desarrollo software dirigido por modelos, denominado \emph{Epsilon}~\cite{kolovos:2011}, el siguiente paso (Figura~\ref{fig:planning}, \emph{T1B}) fue familiarizarse con dicha herramienta.

Para ello fue necesario adquirir ciertos conocimientos sobre EMF (\emph{Eclipse Modelling Framework})~\cite{steinberg:2008}, el lenguaje para la definición de lenguajes de modelado que constituye el corazón de Epsilon; así como con EOL (\emph{Epsilon Object Language})~\citep{kolovos:2006}, lenguaje que constituye la espina dorsal de Epsilon, y que es utilizado por la amplia mayoría de sus lenguajes y herramientas. A continuación, se debió adquirir destreza con el lenguaje a utilizar para la generación de código, EGL (\emph{Epsilon Generation Language})~\citep{rose:2008}.

Además, por exigencias de los usuarios finales de este producto, el código generado debía ser editable como un proyecto de Visual Studio 2010, por lo que a continuación se procedió a familiarizarse con la utilización de dicha herramienta. Para ello, se implementó una línea de productos software sencilla utilizando las técnicas aprendidas hasta este punto, como el \emph{Slicer Pattern}.

Tras esta tarea inicial de adquisición de conocimientos previos, el resto del proyecto se estructura  de acuerdo a las dos fases de una línea de productos software.

La primera tarea tras la fase inicial de documentación fue la fase dedicada a la implementación de los generadores de código para la fase de \emph{Ingeniería del Dominio} (Figura~\ref{fig:planning}, \emph{T2}). Dichos
generadores de código necesarios debían, a partir de un modelo UML 2.0 orientado a características, generar un proyecto Visual Studio, en el lenguaje C\#, y que estuviera implementado acorde a las clases parciales C\# y el \emph{Slicer Pattern}. Para ello deberían generarse las clases parciales correspondientes a cada una de las características, así como los esqueletos de las versiones sucias de los métodos. Dichos esqueletos, al igual que en la metodología original TENTE, deben ser completados a mano.

Para comprobar el correcto funcionamiento de estos generadores de código, se desarrollaron una serie de pruebas unitarias que se implementaron en \emph{EUnit}~\citep{garcia:2011}, el lenguaje para la definición de pruebas unitarias de la suite \emph{Epsilon}.

A continuación, la siguiente fase consistiría en el desarrollo de los generadores de código para la fase de \emph{Ingeniería de Aplicaciones} (Figura~\ref{fig:planning}, \emph{T3}), para lo que se siguió un procedimiento similar al de la fase anterior. La función de estos generadores de código era la de crear las clases parciales destinadas a componer las versiones sucias de cada método, para lo cual se debían generar las versiones limpias de cada método, así como el código para que dichas versiones limpias delegasen en las versiones sucias que correspondiese.

Llegados a este punto, teníamos los generadores de código solicitados, por lo que sólo restaba proceder a su empaquetado y despliegue (Figura~\ref{fig:planning}, \emph{T4}). Este despliegue implicaba su integración dentro de la arquitectura de plugins de Eclipse.

Para ello primero se creó un plug-in para el entorno de desarrollo de Eclipse, de forma que éste tuviese elementos gráficos y la lógica necesaria para invocar a los generadores de código creados. A continuación, tanto los generadores de código cómo el plug-in creados debían empaquetarse y distribuirse de acuerdo a las políticas de desarrollo de plug-ins para Eclipse.

Tras dicha integración, se procedió a realizar una serie de pruebas de aceptación, destinadas a comprobar que el trabajo realizado satisfacía las necesidades de los usuarios finales que iban a utilizar el producto creado.

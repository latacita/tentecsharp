%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.1, 21/04/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Domain Engineering/Generadores de Código C#                      %%
%%==================================================================%%
Tras explicar a grandes rasgos las transformaciones de modelo a código en la sección \ref{domain:sec:transf}, se procede a comentar la implementación de los generadores de código correspondientes. La figura \ref{dom:fig:templates} muestra la jerarquía de los generadores de código implementados.

\begin{figure}[!tb]
  \center
  \includegraphics[scale=0.80,angle=90]{domainEngineering/images/Templates.eps} \\
  \caption{Jerarquía de los generadores de código implementados}
  \label{dom:fig:templates}
\end{figure}

El punto de partida es el generador de código llamado \imp{ProjectCreation}, a partir de el se invoca a la plantilla \imp{ClassFilesCreation} que determina si un elemento es:

 \begin{itemize}
   \item Una clase o interfaz, en tal caso llamaría a su vez al generador de código \imp{ClassCreation}.
   \item Una clase con herencia múltiple, en este caso se requiere un tratamiento especial que veremos más adelante en detalle, en tal caso llamaría a su vez a los generadores de código \imp{ClassCreationMultipleHierarchyCase}, \imp{ChildClassHierarchyCase} e \imp{InterfaceCreation}.
 \end{itemize}

 Una vez se ha determinado el tipo de elemento de los descritos en la enumeración anterior, se procede a generar el fichero fuente correspondiente a dicho elemento. Para ello, y en un orden secuencial estricto, se hacen llamadas a las plantillas descritas en forma de árbol en la figura \ref{dom:fig:templates}. Por ejemplo, para la generación de una clase el proceso sería tal como se muestra a continuación:
 \begin{enumerate}
   \item ProjectCreation
   \item ClassFilesCreation, se determina que es una clase.
   \item ClassCreation, se indica la ruta para guardar el fichero que se va a generar.
   \item ModelCreation, genera el namespace del proyecto.
   \item ClassDeclaration, genera la declaración de la clase parcial.
   \item PropertiesGeneration, genera las propiedades de la clase.
   \item MethodsCreation, genera los métodos de la clase.
   \item UtilityMethodsCreation, genera los métodos de utilidad de la clase.
   \item Una vez generados todos los elementos de la clase, se genera el fichero fuente correspondiente.
 \end{enumerate}

 Después de haber generado todos los paquetes, clases e interfaces del proyecto se deben generar los ficheros necesarios para que dicho proyecto pueda ser abierto con el programa Visual Studio sin problemas. Para ello es necesario generar una serie de ficheros específicos de dicha plataforma, los ficheros se describen a continuación:
 \begin{itemize}
   \item SlnFileCreation, genera el fichero .sln que contiene información del entorno del sistema.
   \item CsprojectFilesCreation, genera el fichero .csproj correspondiente para incluir los directorios creados en el proyecto Visual Studio.
   \item AssemblyInfoFileCreation, genera el fichero .cs que contiene la información general sobre las directivas de ensamblado.
 \end{itemize}

 Aunque no aparezca en el diagrama, todos los generadores de código utilizan además el fichero Operations, que es un fichero EOL que dispone de operaciones básicas que se utilizan recurrentemente en el resto de generadores, por nombrar algunos ejemplos, dicho fichero contiene funciones del estilo:
 \begin{itemize}
   \item \emph{abstract}, retorna el texto \imp{abstract} cuando el elemento sobre el que está siendo utilizado es abstracto.
   \item \emph{typeCollection}, retorna el tipo de colección correspondiente al elemento sobre el que se está actuando.
   \item \emph{hierarchy}, retorna las clases de las que hereda el elemento en cuestión.
 \end{itemize}

 Adicionalmente a los generadores de código EGL y EOL, en los sucesivos párrafos se habla en detalle de los Java Tools adicionales que se han elaborado para hacer más gráfico y sencillo al usuario el proceso de ejecución de los generadores de código.

 \paragraph{Java Tool} \ \\

 Un Java Tool es una porción de código java que tras ser empaquetada como plug-in se puede incorporar en el directorio de instalación de Epsilon y utilizar las funciones implementadas en las plantillas de generación de código creadas. Se han desarrollado cuatro Java Tools en total:

 \begin{figure}[!tb]
  \centering
  \includegraphics[width=.75\linewidth]{domainEngineering/images/VentanaDirectorio.eps} \\
  \caption{Selección de directorio donde emplazar el proyecto a generar}
  \label{dom:fig:dir}
\end{figure}

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.75\linewidth]{domainEngineering/images/ErrorWindow.eps} \\
  \caption{Ventana de error}
  \label{dom:fig:error}
\end{figure}

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.75\linewidth]{domainEngineering/images/FinalWindow.eps} \\
  \caption{Ventana al final de la generación de código}
  \label{dom:fig:final}
\end{figure}

 \begin{itemize}
   \item pluginCreateDirectories, genera los directorios en el sistema.
   \item pluginCreateMessageWindow, genera la ventana con los errores y/o información oportunos (figura \ref{dom:fig:error}).
   \item pluginCreateSelectDirectoryWindow, genera un entorno de exploración por el equipo para elegir el destino de la generación del proyecto (figura \ref{dom:fig:dir}).
   \item pluginCreateWindowAndShowMessages, genera una ventana al final de la ejecución con información para el usuario (figura \ref{dom:fig:final}).
   \item pluginWriteInFile, genera el fichero que contendrá la información para mostrar al usuario al final la ejecución.
 \end{itemize}

Para utilizar los Java Tools en los generadores de código es necesario implementar funciones EOL para cada una de las funciones descritas ellos. El listing \ref{dom:code:writeinfile} muestra un ejemplo de cómo se realiza dicho proceso, en las líneas 1-4 se describe la creación de la función a utilizar en los generadores de código, en la línea 5 se importa dicho fichero EOL para hacer uso de las funciones implementadas en el generador \imp{ProjectCreation}, mientras que la línea 7 muestra la forma de uso de la función \imp{writeInFile}.

\begin{lstlisting} [basicstyle=\ttfamily\scriptsize,language=CSharp, captionpos=b,
                    caption=Uso de un Java Tool en los generadores de código,
                    label=dom:code:writeinfile]
File Operations.eol
--------------------------------------------------------
01 operation writeInFile(path:String, message:String) {
02     var sampleTool = new Native("pluginWriteInFile.WriteInFile");
03     sampleTool.writeInFile(path, message);	
04}

File ProjectCreation.egl
--------------------------------------------------------
05 import "Operations.eol"
06 ...
07 writeInFile(path+"\\log.txt", message);
08 ...
\end{lstlisting}

 Una vez explicado el funcionamiento de los generadores de código y los java tools implementados, en las siguientes secciones se procederá a explicar de forma detallada varios ejemplos de generadores. Primero uno sencillo que sea fácil de comprender para el lector no experto en el tema y después dos casos más complejos.

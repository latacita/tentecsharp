%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 21/04/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Domain Engineering/Transformación UML a C#                       %%
%%==================================================================%%
\begin{table}%
\begin{tabularx}{15cm}{|l|X|}
\hline
{\bf Elemento en UML} & {\bf Elemento en C\#} \\
\hline
   % Modelo
\multicolumn{ 1}{|l|}{Modelo} &
   Namespace del proyecto. Los namespaces permiten agrupar entidades tales como paquetes, clases, objetos y funciones bajo el mismo nombre. De esta forma, se pueden tener varios namespaces en el mismo proyecto que son independientes entre sí. \\
\hline
   % Paquete
\multicolumn{ 1}{|l|}{Paquete  } &
    Puede ser un directorio, con el mismo nombre que dicho paquete en el modelo, y que contenga tantos ficheros como clases o interfaces almacene en su interior. O un directorio vacío, con el mismo nombre que dicho paquete en el modelo, por cada paquete vacío que haya en el modelo UML.   \\
\hline
   % Atributo
\multicolumn{ 1}{|l|}{Atributo} &
    Cada atributo será tratado como una propiedad de C\# con los correspondientes métodos getter y setter. Si el atributo tiene visibilidad \emph{protected} o es \emph{static} no poseerá los métodos getter y setter. \\
\hline
   % Parámetro
\multicolumn{ 1}{|l|}{Parámetro} &
    Después de identificar si es de retorno de una operación o de entrada a la misma se aplica la transformación al tipo de dato correspondiente.\\
\hline
    % Clase
\multicolumn{ 1}{|l|}{Clase} &
    Clase parcial C\# siguiendo el patrón slicer, es decir $<$nombre del paquete al que pertenece$>$\_$<$nombre de la clase$>$. Al crear la clase, añadir también los métodos de utilidad. \\
\hline
   % Interfaz
\multicolumn{ 1}{|l|}{Interfaz} &
   Interfaz C\#  implementada siguiendo el patrón slicer. \\
\hline
   % Operacion
\multicolumn{ 1}{|l|}{Operación} &
    Método C\# privado y renombrado siguiendo el patrón slicer de la forma $<$nombre del paquete al que pertenece$>$\_$<$nombre de la operación$>$, para evitar posibles conflictos, todos los métodos serán virtuales. Los métodos \emph{protected} no se cambiarán a privados para respetar la visibilidad requerida inicialmente por el usuario.  \\
\hline
   % Constructor
\multicolumn{ 1}{|l|}{Constructor} &
    Cada clase parcial correspondiente a una característica tendrá un método privado llamado $<$nombre del paquete al que pertenece$>$\_init$<$nombre de la clase$>$ que contendrá la porción de constructor que corresponde a la característica. \\
\hline
   % Asociación entre clases
\multicolumn{ 1}{|l|}{Asociación} &
    \emph{Asociación simple:} Se añade el atributo, simple o colección, de tipo Class a la clase destino.\\
\multicolumn{ 1}{|l|}{} &
    \emph{Asociación bidireccional:} Dependiendo del tipo de bidireccionalidad (one to one, one to many o many to many) se añaden los atributos y métodos adicionales necesarios para implementar el correcto funcionamiento de dicha asociación.  \\
\hline
   % Generalización
\multicolumn{ 1}{|l|}{Generalización} &
    \emph{Herencia simple:} Una clase hereda de otra clase.\\
\multicolumn{ 1}{|l|}{} &
    \emph{Herencia múltiple:} Una clase hereda de varias clases y se debe realizar la transformación correspondiente mediante la creación de interfaces ya que en C\# no se permite la herencia múltiple de varias clases pero sí de varias interfaces.   \\
\hline
\end{tabularx}
  \caption{Transformación de elementos del modelo UML a código C\#}
  \label{dom:fig:tranf}
\end{table}%

 \begin{figure}[!tb]
  \centering
  \includegraphics[width=.95\linewidth]{domainEngineering/images/Transformaciones.eps} \\
  \caption{Ejemplo de Modelo UML simplificado}
  \label{dom:fig:ejemplo}
\end{figure}

 El primer paso para la transformación de modelo a código (\emph{model-to-text}, M2T) es la identificación de los distintos elementos que nos podemos encontrar en un diagrama de clases UML y hallar el equivalente en código (C\# en nuestro caso). Hay que tener en cuenta que la transformación no es trivial y es necesario procesar la información obtenida del modelo para generar el código adecuadamente. En la tabla \ref{dom:fig:tranf} se encuentra un resumen de dicho proceso. A continuación se procede al análisis más detallado de cada uno de los elementos de dicha tabla, para ello nos apoyaremos en la figura \ref{dom:fig:ejemplo}.
\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
File PaqueteLleno/B.cs
--------------------------------------------------------
01 namespace Ejemplo{
02 		partial class B: C{
03			...
04			private virtual void B_initB ( ) {}
05			protected virtual PaqueteLleno_println ( ) {}
06		}
07 }

File PaqueteLleno/A.cs
--------------------------------------------------------
08 namespace Ejemplo{
09 		partial class A: C{
10			private B elemB;
11			public B elemB {
12				get { return this.elemB; }
13				set { this.elemB= value; }
14			}
15			...
16			private virtual void A_initA ( ) {}
17			private virtual ISet<B> PaqueteLleno_add (int a) { }
18		}
19 }

File PaqueteLleno/C.cs
--------------------------------------------------------
20 namespace Ejemplo{
21 		partial class C: I{
22			private int num;
23			public int num {
24				get { return this.num; }
25				set { this.num= value; }
26			}
27			...
28			private virtual void C_initC ( ) {}
29		}
30 }

File PaqueteLleno/I.cs
--------------------------------------------------------
31 namespace Ejemplo{
32 		partial interface I{			
33			public virtual override bool Equals (Object o);
34			public virtual override int CompareTo (Object o);
35			public virtual override int GetHashCode ( );
36			public virtual override Type GetType ( );
37			public virtual override string ToString( );
38			private virtual void I_initI ( ) {}
39		}
40 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Código generado para las clases y la interfaz del modelo de la figura \ref{dom:fig:ejemplo}}
\label{dom:code:ejemplo}
\end{figure}

El modelo de la figura \ref{dom:fig:ejemplo} es \imp{Ejemplo} y por tanto cada clase del proyecto debería comenzar definiendo el namespace del modelo en cuestión mediante la línea de código C\# tal como se aprecia en las líneas 1, 8, 20 y 31 de la figura \ref{dom:code:ejemplo}.

En la figura \ref{dom:fig:ejemplo} hay dos paquetes \imp{PaqueteLleno} y \imp{PaqueteVacío}, por tanto, en el directorio destino donde se generan los ficheros del modelo deberán aparecer dos carpetas con dichos nombres. La carpeta \imp{PaqueteLleno} contendrá en su interior cuatro ficheros denominados A.cs, B.cs, C.cs e I.cs (jerarquía indicada en las líneas 1, 11, 26 y 40 de la figura \ref{dom:code:ejemplo}), uno por cada clase o interfaz que se encuentra en su interior, mientras que la carpeta \imp{PaqueteVacío} no contendrá ningún archivo en su interior.

Tal como se aprecia en la figura \ref{dom:fig:ejemplo}, la clase \imp{A} del paquete \imp{PaqueteLleno}, tiene un atributo llamado \imp{num} por lo que se genera una propiedad con sus respectivos métodos getter y setter tal como se muestra en la figura \ref{dom:code:ejemplo} en las líneas 22-26.

La figura \ref{dom:fig:ejemplo} presenta la clase \imp A con una operación \imp{add} que tiene un parámetro \imp{a: int} y retorna una colección de elementos de tipo \imp{B} (figura \ref{dom:code:ejemplo} línea 17). De la misma forma, la clase \imp{B} tiene una operación \imp{println} de carácter \emph{protected} y por tanto su visibilidad no se transforma en \emph{private} (figura \ref{dom:code:ejemplo} línea 5). Con este ejemplo quedan ilustrados los puntos de operación y parámetro descritos en la tabla \ref{dom:fig:tranf}.

Para la generación de clases e interfaces de la figura \ref{dom:fig:ejemplo}, el resultado sería el mostrado en las líneas 2, 9, 21 y 32 de la figura \ref{dom:code:ejemplo}. Se aprecia también las herencias correspondientes.

Aunque no esté reflejado en el modelo UML añadimos a cada clase, o interfaz, del modelo añadimos un constructor (figura \ref{dom:code:ejemplo} líneas 4, 16, 28 y 38) y unos métodos de utilidad (figura \ref{dom:code:ejemplo} líneas 33-37).

Por último, la asociación simple de las clases \imp{A} y \imp{B} se traduce con las líneas de código descritas en las líneas 10-14 de la figura \ref{dom:code:ejemplo}.

Con esto queda explicado más detalladamente la transformación de modelo UML a código C\# descrita en la tabla \ref{dom:fig:tranf}. Se han omitido la herencia múltiple y las asociaciones bidireccionales por su complejidad. En la siguiente sección se profundizará en la implementación y creación de las transformaciones de modelo UML a código C\#.

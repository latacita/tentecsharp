%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.5, 15/05/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Application Engineering/Algoritmo                                %%
%%==================================================================%%

Para obtener una implementación completamente funcional de un producto concreto, con unas características determinadas, de acuerdo con el \emph{Slicer Pattern} (ver Sección~\ref{}), es necesario: (1) crear una clase parcial por cada clase que deba estar incluida en el producto final; (2) crear la \emph{versión limpia} de cada constructor y cada método que deba estar incluido en el producto final; y (3) hacer que dichas versiones limpias deleguen en las \emph{versiones sucias} que corresponda. 

El primer paso en el proceso de transformación es crear un nuevo proyecto y una nueva carpeta que represente el producto final. 

Para calcular todas las clases que deben estar incluidas en el producto final, recorremos el modelo desde el paquete que representa el producto concreto, y que será siempre un paquete \emph{hoja}, hacia arriba, hasta llegar a la raíz, o raíces, del modelo orientado a características. Normalmente, siempre hay un modelo raíz que contiene los elementos que son comunes a todos los productos. 
En nuestro caso, dicho recorrido generaría dos caminos distintos: (1) \imp{SmartEnergyMng}, \imp{WindowMng}, \imp{BaseSystem}; y (2) \imp{SmartEnergyMng}, \imp{HeaterMng}, \imp{BaseSystem}.

Obviamente, una clase puede aparecer en más de un paquete. Por ejemplo, la clase \imp{Gateway} aparece en todos los paquetes, a excepción del que representa el producto final, de la Figura~\ref{}. No obstante, cada clase que esté en un camino desde el paquete hoja al paquete raíz, solo debe incluirse una vez en el producto final, aunque ésta aparezca varias veces. Por cada clase distinta presente en algunos de los caminos del paquete hoja a la raíz, generamos una nueva clase parcial, que colocamos en la carpeta que representa el producto final

A continuación, para cada clase, debemos calcular todos los métodos limpios que debemos generar. Para ello, al igual que ocurría con las clases parciales, recorremos todos los caminos existentes de raíz a hoja. Para cada clase, por cada método distinto, es decir, con diferente signatura, creamos una versión limpia de dicho método dentro de la clase parcial incluida en el producto final. El proceso de generación del esqueleto del método se realiza reutilizando las plantillas de generación de código y facilidades creadas para la Ingeniería de Dominio.

Por último, quedaría por generar el código de cada método, de forma que este delegue en la versión sucia del método que corresponda. Es esta fase del algoritmo de generación de código la que entraña mayor dificultad, porque pueden darse diversos casos. Analizamos cada caso a continuación.

\subsection{Caso 1: Sólo existe una \emph{versión sucia} del método}

Se trata del caso más simple. Sólo existe una \emph{versión sucia} del método, por lo que hay que hacer es delegar en él. \todo{Poner ejemplo con la figura}

\subsection{Caso 2: Existen varias \emph{versiones sucias} independientes}

\subsection{Caso 3: Existen \emph{versiones sucias} dependientes de un método}

\subsection{Caso 3: Existen \emph{versiones sucias} dependientes e independientes de un método}

%%===============================================================================================%%
%% NOTA(Pablo): Esto con las A, B y C es un lío y no me entero muy bien, así que mejor lo        %%
%%              eliminamos                                                                       %%
%%===============================================================================================%%


En la presente sección de describirá de forma detalla el proceso de generación de código para un producto específico, para ello nos apoyaremos en la figura \ref{app:fig:ejemplo}.
\begin{figure}[!tb]
  \center
  \includegraphics[scale=0.50,angle=0]{applicationEngineering/images/Algoritmo.eps} \\
  \caption{Ejemplo de apoyo para la explicación del algoritmo}
  \label{app:fig:templates}
\end{figure}


Nos encontramos así con dos conflictos, puesto que la misma clase (en nuestro caso la clase \imp{A} y la \imp{B}) está implementadas en dos paquetes diferentes. En estos casos, debemos buscar las operaciones que dicha clase implementa en ambos paquetes, de esta forma tenemos que:
\begin{itemize}
  \item Clase A, implementa las operaciones \imp{println()} y \imp{remove (int i)} en el paquete \imp{Cuatro}, mientras que en el paquete \imp{Uno} implementa la operación \imp{println()}.
  \item Clase B, implementa la operación \imp{close()} en el paquete \imp{Cuatro}, mientras que en el paquete \imp{Uno} implementa la operación \imp{open()}.
\end{itemize}
En este punto tenemos un conflicto, en la operación \imp{println()} de la clase \imp{A}, ya que tenemos dos versiones del método la implementada en el paquete \imp{Cuatro} y la implementada en el paquete \imp{Uno}, nos quedamos con la versión más profunda del método es decir, con la versión implementada en el paquete \imp{Cuatro}.

Para la generación del constructor de las clases basta con comprobar el paquete más profundo donde está implementada dicha clase, en nuestro ejemplo:
\begin{itemize}
  \item Clase A, implementada en el paquete \imp{Cuatro}.
  \item Clase B, implementada en el paquete \imp{Cuatro}.
  \item Clase C, implementada en el paquete \imp{Uno}.
\end{itemize}

\begin{lstlisting} [basicstyle=\ttfamily\scriptsize,language=CSharp, captionpos=b,
                    caption=Código generado para el producto específico seleccionado en la figura \ref{app:fig:ejemplo},
                    label=app:code:ejemplo]
File Cinco/A.cs
--------------------------------------------------------
01 namespace My_Ejemplo{
02     public class A{
03        public virtual void A ( ) {
04             Cuatro_A_initA ( );
05        }
06        public virtual println ( ) {
07	           Cuatro_println ( );
08        }
09        public virtual remove ( int i ) {
10             Cuatro_remove ( i );
11        }
12     }
13 }

File Cinco/B.cs
--------------------------------------------------------
14 namespace My_Ejemplo{
15     public class B{
15          public virtual void B_initB ( ) {
16              Cuatro_B_initB ( );
17          }
18          public virtual close ( ) {
19              Cuatro_close ( );
20          }
21     }
22 }

File Cinco/C.cs
--------------------------------------------------------
23 namespace My_Ejemplo{
24     public class C{
25          public virtual void C_initC ( ) {
26              Uno_C_initC ( );
27          }
28          public virtual ISet<int> add ( int i) {
29              Uno_add ( i );
30          }
31     }
32 }

\end{lstlisting}

Procedemos entonces a generar el código para la versión clean de tanto la clase como los métodos tal como se aprecia en el listing \ref{app:code:ejemplo}.

Renombramos el modelo aplicado añadiendo un "My\_" (líneas 1, 14 y 23) para denotar que ese es el modelo que contiene la implementación específica del producto seleccionado.

Tal como comentamos anteriormente, la llamada interna de los constructores se corresponde con la de aquel paquete más profundo en la selección específica que implemente dicha clase (líneas 4, 16 y 26).

Y tras resolver los conflictos con aquellos métodos implementados en varios paquetes (en nuestro ejemplo el método \imp{print()} de la clase \imp{A}) obtenemos el código descrito en el listing \ref{app:code:ejemplo}.

\begin{figure}[!tb]
  \center
  \includegraphics[scale=0.50,angle=0]{applicationEngineering/images/Algoritmo1.eps} \\
  \caption{Ejemplo complejo de apoyo para la explicación del algoritmo}
  \label{app:fig:ejemplo1}
\end{figure}

Analizamos ahora un ejemplo más complejo de generación de código de un producto específico, supongamos ahora el ejemplo descrito en la figura \ref{app:fig:ejemplo1}.

En este caso tenemos tres rutas: \imp{Cinco} $\rightarrow$ \imp{Seis} $\rightarrow$ \imp{Tres} $\rightarrow$ \imp{Uno}, \imp{Cinco} $\rightarrow$ \imp{Seis} $\rightarrow$ \imp{Cuatro} $\rightarrow$ \imp{Uno} y \imp{Cinco} $\rightarrow$ \imp{Dos} $\rightarrow$ \imp{Uno}.

Debemos por tanto analizar los caminos independientes, en este caso hay dos, por un lado el camino \imp{Cinco} $\rightarrow$ \imp{Dos} $\rightarrow$ \imp{Uno} y por otro el formado por \imp{Cinco} $\rightarrow$ \imp{Seis} (que se bifurca a su vez en dos).

A la hora de extraer la implementación interna de los métodos, debemos incluir ambas ramas puesto que son independientes entre sí y por tanto sus versiones de los métodos no entran en conflicto. De esta forma, y tal como se describe en el listing \ref{app:code:ejemplo1}, para la clase \imp{B} tanto el método \imp{close()} como el constructor se realizan llamadas internas a ambas versiones de dicho paquete (líneas 15-22).

Para la implementación interna de la clase A, procedemos de manera análoga al ejemplo \ref{app:fig:ejemplo}, es decir, la clase \imp{A} implementará los métodos \imp{print()}, \imp{add(int i)}, \imp{remove()} y el constructor (listing \ref{app:code:ejemplo1}, líneas 3-14). Como los caminos \imp{Cinco} $\rightarrow$ \imp{Seis} $\rightarrow$ \imp{Tres} $\rightarrow$ \imp{Uno} y \imp{Cinco} $\rightarrow$ \imp{Seis} $\rightarrow$ \imp{Cuatro} $\rightarrow$ \imp{Uno} son dependientes entre sí, debemos seleccionar una vez más las versiones más profundas de cada método que entre en conflicto.

\begin{lstlisting} [basicstyle=\ttfamily\scriptsize,language=CSharp, captionpos=b,
                    caption=Código generado para el producto específico seleccionado en la figura \ref{app:fig:ejemplo1},
                    label=app:code:ejemplo1]
File Cinco/A.cs
--------------------------------------------------------
01 namespace My_Ejemplo{
02     public class A{
03          public virtual void A ( ) {
04              Seis_A_initA ( );
05          }
06          public virtual println ( ) {
07              Seis_println ( );
08          }
09          public virtual add ( int i ) {
10              Seis_add ( i );
11          }
12          public virtual remove ( int i ) {
13              Cuatro_remove ( i );
14          }
15     }
16 }

File Cinco/B.cs
--------------------------------------------------------
14 namespace My_Ejemplo{
15     public class B{
15          public virtual void B_initB ( ) {
16              Dos_B_initB ( );
17              Seis_B_initB ( );
18          }
19          public virtual close ( ) {
20              Dos_close ( );
21              Seis_close ( );
22          }			
23     }
24 }

File Cinco/C.cs
--------------------------------------------------------
25 namespace My_Ejemplo{
26     public class C{
27          public virtual void C_initC ( ) {
28              Uno_C_initC ( );
29          }
30          public virtual ISet<int> add ( int i) {
31              Uno_add ( i );
32          }
33     }
34 }

\end{lstlisting}

Al igual que como se ha comentado hasta ahora, también podemos incluir más de un paquete con profile para generar varios productos específicos, para cada uno de ellos se creará la implementación específica seleccionada, las soluciones son obviamente independientes entre sí.

Así pues queda explicado en detalle el proceso de generación de código para un producto específico del modelo UML a código C\#. En la siguiente sección se profundizará en la implementación y generación de código C\#.

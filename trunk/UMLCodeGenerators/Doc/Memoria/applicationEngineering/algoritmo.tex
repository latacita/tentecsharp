%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.5, 15/05/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Application Engineering/Algoritmo                                %%
%%==================================================================%%

Para obtener una implementación completamente funcional de un producto concreto, con unas características determinadas, de acuerdo con el \emph{Slicer Pattern} (ver Sección~\ref{sec:back:slicer}), es necesario: (1) crear una clase parcial por cada clase que deba estar incluida en el producto final; (2) crear la \emph{versión limpia} de cada constructor y cada método que deba estar incluido en el producto final; y (3) hacer que dichas versiones limpias deleguen en las \emph{versiones sucias} que corresponda.

El primer paso en el proceso de transformación es crear un nuevo proyecto y una nueva carpeta que represente el producto final.

Para calcular todas las clases que deben estar incluidas en el producto final, recorremos el modelo desde el paquete que representa el producto concreto, y que será siempre un paquete \emph{hoja}, hacia arriba, hasta llegar a la raíz, o raíces, del modelo orientado a características. Normalmente, siempre hay un modelo raíz que contiene los elementos que son comunes a todos los productos.
En nuestro caso de la Figura~\ref{app:fig:conf1}, dicho recorrido generaría dos caminos distintos: (1) \imp{SmartEnergyMng}, \imp{WindowMng}, \imp{InitialModel}; y (2) \imp{SmartEnergyMng}, \imp{HeaterMng}, \imp{InitialModel}.

Obviamente, una clase puede aparecer en más de un paquete. Por ejemplo, la clase \imp{Gateway} aparece en todos los paquetes, a excepción del que representa el producto final, de la Figura~\ref{app:fig:conf1}. No obstante, cada clase que esté en un camino desde el paquete hoja al paquete raíz, solo debe incluirse una vez en el producto final, aunque ésta aparezca varias veces. Por cada clase distinta presente en algunos de los caminos del paquete hoja a la raíz, generamos una nueva clase, que colocamos en la carpeta que representa el producto final.

A continuación, para cada clase, debemos calcular todos los métodos limpios que debemos generar. Para ello, al igual que ocurría con las clases parciales, recorremos todos los caminos existentes de raíz a hoja. Para cada clase, por cada método distinto, es decir, con diferente signatura, creamos una versión limpia de dicho método dentro de la clase parcial incluida en el producto final. El proceso de generación del esqueleto del método se realiza reutilizando las plantillas de generación de código y facilidades creadas para la Ingeniería de Dominio.

Por último, quedaría por generar el código de cada método, de forma que éste delegue en la versión sucia del método que corresponda. Es esta fase del algoritmo de generación de código la que entraña mayor dificultad, porque pueden darse diversos casos. Analizamos cada caso a continuación.

\subsection{Caso 1: Sólo existe una \emph{versión sucia} del método}

Se trata del caso más simple. Sólo existe una \emph{versión sucia} del método, por lo que hay que hacer es delegar en él. En el ejemplo de la Figura~\ref{app:fig:conf1}, para la clase \imp{Gateway}, el método \imp{WindowCtrl.open}  solo está implementado en la característica \imp{WindowMng}, por lo que el código generado para la \emph{versión limpia} de dicho método simplemente contendría un delegado a la \emph{versión sucia} \imp{windowMng\_open} de dicho método.

\subsection{Caso 2: Existen varias \emph{versiones sucias} independientes}

\begin{figure}[!tb]
  \center
  \includegraphics[width=0.60\linewidth,keepaspectratio=true]{applicationEngineering/images/Configuration(2).eps} \\
  \caption{Configuración de una casa inteligente con versiones sucias independientes de un mismo método}
  \label{app:fig:conf2}
\end{figure}

En este caso, existen varias \emph{versiones sucias} independientes del método. Por independientes entendemos que dichas versiones se encuentran en caminos distintos, y ninguna es \emph{alcanzable} desde la otra. El ejemplo de la Figura~\ref{app:fig:conf1} no contiene ninguno de estos casos, por lo que usamos el ejemplo de la Figura~\ref{app:fig:conf2}, extraído del mismo caso de estudio. Por razones de concisión y brevedad, en dicho ejemplo sólo aparecen aquellos detalles que son relevantes para explicar la situación que estamos tratando.

En este caso, se trata de una configuración de un producto concreto que incluye las características \imp{BlindSimulation} y \imp{LightSimulation}, encargadas de simular la presencia de habitantes en el hogar mediante el movimiento de persianas y el encendido y apagado de luces. Obviamente, ambas características dependen de las características de gestión automática de persianas (\imp{BlindMng}) y gestión automática de luces (\imp{LightMng}), respectivamente. En cada una de estas características, se extiende la clase \imp{Gateway} para que contenga métodos para iniciar y detener la simulación (\imp{startSimulation} y \imp{stopSimulation}, respectivamente).

En este caso, la versión limpia de los métodos \imp{startSimulation} y \imp{stopSimulation}, contenida dentro del paquete \imp{MyHome}, debe delegar en las versiones sucias del método perteneciente tanto a \imp{BlindSimulation} como \imp{LightSimulation}, ya que en este caso, al inicial la simulación de presencia, deben activarse tanto la simulación de persianas como de luces. Es decir, por ejemplo, el método \imp{startSimulation}, de \imp{MyHome}, contendrá en su interior llamadas a \imp{blindSimulation\_startSimulation} y a \imp{lightSimulation\_startSimualtion}. El orden el cual se generen estas llamadas es irrelevante.

\subsection{Caso 3: Existen \emph{versiones sucias} dependientes de un método}

En este caso, existen varias \emph{versiones sucias} de un método, pero dichas versiones están en el mismo camino, estando una situada a mayor profundidad, más cerca del paquete \emph{hoja} que la otra. Por ejemplo, en el caso de la Figura~\ref{app:fig:conf1}, existen dos versiones del método \imp{openWindow}, de la clase \imp{Gateway}, en las características \imp{SmartEnergyMng} y \imp{WindowMng}. Ambas están en el mismo camino del paquete hoja al paquete raíz (\imp{SmartEnergyMng}, \imp{WindowMng}, \imp{InitialModel}).

En este caso, de acuerdo a la semántica del modelo UML 2.0, la versión del paquete \imp{SmartEnergyMng} debe sobrescribir la versión del paquete \imp{WindowMng}. Por tanto, la versión limpia del método debe invocar en este caso sólo a la versión sucia del paquete \imp{SmartEnergyMng}, ya que se entiende que esta versión \emph{más profunda} es la más actualizada. En caso de haber más de dos versiones dependientes, siempre se escogería la versión más profunda.

\subsection{Caso 4: Existen \emph{versiones sucias} dependientes e independientes de un método}

Este caso se trata de una combinación de los casos 2 y 3. Existen diversas versiones de un método. Estas versiones las podemos agrupar en varios subconjuntos, donde cada subconjunto contiene todas las versiones que son dependientes entre sí. Por ejemplo, para la Figura~\ref{app:fig:conf1}, consideremos el caso del constructor de la clase \imp{Gateway}. Supongamos además, que la característica \imp{LightMng} también está seleccionada. Dicho constructor, aunque no se muestra de forma explícita en el diagrama, estaría presente en todas las versiones de dicha clase, presente en cada una de las características del sistema.

Para la Figura~\ref{app:fig:conf1}, hay tres caminos distintos (recordemos que la característica \imp{LightMng} también está seleccionada, aunque no aparezca en la figura): (1) \imp{MyHome}, \imp{SmartEnergyMng}, \imp{WindowMng}, \imp{InitialModel}; (2) \imp{MyHome}, \imp{SmartEnergyMng}, \imp{HeaterMng}, \imp{InitialModel}; y, (3) \imp{MyHome}, \imp{LightMng}, \imp{InitialModel}. En este caso, habría 5 versiones del constructor de la clase \emph{Gateway}, más concretamente \imp{smartEnergyMng\_Gateway}, \imp{windowMng\_Gateway}, \imp{heaterMng\_Gateway}, \imp{lightMng\_Gateway} y \imp{initialModel\_Gateway}. Tendríamos dos conjuntos de métodos dependientes, \{ \imp{smartEnergyMng\_Gateway}, \imp{windowMng\_Gateway}, \imp{heaterMng\_Ga-teway}, \imp{initialModel\_Gateway} \}, y \{ \imp{lightMng\_Gateway} y \imp{initialModel\_Gateway} \}.

En este caso, la versión limpia del método debe invocar la versión más profunda de cada conjunto independiente de métodos, en este caso \imp{smartEnergyMng\_Gateway} y \imp{lightMng\_Gateway}. Al igual que en el caso 2, el orden en el cual se invocan estos métodos es irrelevante.

La siguiente sección describe, de forma muy superficial, cómo se organizan las plantillas encargadas de implementar este no trivial algoritmo de generación de código.

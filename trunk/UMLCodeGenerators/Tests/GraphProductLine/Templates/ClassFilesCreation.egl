[%
////////////////////////////////////////////////////////////
//
// Author: Patricia Abascal Fernández
// Version: 1.9
// Last modification: 08/04/2013 
// Description: Generates the files of all code classes. And
//				return a set of all the paths.
////////////////////////////////////////////////////////////
import "Operations.eol";
import "ClassElements/MethodsCreation.egl";
import "ClassElements/PropertiesGeneration.egl";
import "BidirectionalRelations/BidirectionalRelations.egl";
import "Classes/MultipleHierarchyClasses.egl";
operation classFilesCreation(packages: Set, modelProject: Model, directory: String, path: String){
	var paths_empty: Set; 
	var paths_notempty: Set; 
	var isInterface=false;
	
	var isBidirectional=false;
	var bidirectionalImplementations: List; 
	
	// Select bidirectional relations
	var bidirectionalRelations=bidirectionalRelations();
	for (pack in packages) {
		// If the package doesn't have name, throw an exception
		if (pack.name=""){
			var message = "EXCEPTION: There is a package which doesn't have a name. Please name it in order to generate the project.";
			createErrorWindow(message); 
			throw (message);
		}
		// Enumeration classes from the model
		var enumClasses=pack.packagedElement.select(e|e.isTypeOf(Enumeration));
		if (enumClasses.size>0){
			var message = "EXCEPTION: There is an enumeration class in the package \""+pack.name+"\". Enumeration classes aren't currently supported.";
			createErrorWindow(message); 
			throw (message);
		}
		// Classes from the model
	    var classes=pack.packagedElement.select(e|e.isTypeOf(Class)); 
	    // Interfaces from the model
	    var interfaces=pack.packagedElement.select(e|e.isTypeOf(Interface));	    
		// Packages from the model
	    var packag=pack.packagedElement.select(e|e.isTypeOf(Package));
	    if (packag.size>0){
	    	for (p in packag){
	    		var pa=classFilesCreation(packag, modelProject, directory + pack.name +"\\", path); 
				paths_empty=paths_empty+pa[0]; 
				paths_notempty=paths_notempty+pa[1];   
	    	}
	    } 
	    // If the package is empty
	    if (classes.size()==0 and interfaces.size()==0){
	    	var path = directory+pack.name + "\\"; 
	    	directory(path);
	    	// Pick the part from the path neccesary to generate empty VS folders
	    	var position=directory.lastIndexOf("src") ;
	    	path=path.substring(position, path.length()); 
	    	paths_empty.add(path); 
	    // If it's not empty, create all the classes and interfaces inside the package
	    }else{
	    	// Create the classes (the ones which are child of none or one class).
			for (class in classes) {
				// If the class doesn't have name, throw an exception
				if (class.name=""){
					var message = "EXCEPTION: There is a class which doesn't have a name in the package \""+pack.name+"\". Please name it in order to generate the project.";
					createErrorWindow(message); 
					throw (message);
				}
				var hierarchy = class.hierarchy(); 
				if (hierarchy.size<=1){ 
					isInterface=false;
					var t := TemplateFactory.load('ClassCreation.egl');
					t.populate ('currentElement', class);	
					t.populate('currentPackage', pack);
					t.populate('currentModel', modelProject);  
					t.populate('path', path); 
					t.populate('isInterface', isInterface); 
					t.populate('bidirectionalRelations', bidirectionalRelations);  
					var path=directory+ pack.name + "\\"+ class.name +'.cs'; 
					t.generate (path); 	
					paths_notempty.add(path);
				}//if-hiearchy
			}//for-class 
			// Create the interfaces
			for (interface in interfaces) {
				// If the interface doesn't have name, throw an exception
				if (interface.name=""){
					var message = "EXCEPTION: There is an interface which doesn't have a name in the package \""+pack.name+"\". Please name it in order to generate the project.";
					createErrorWindow(message); 
					throw (message);
				}
		     	isInterface=true;
		  		var t := TemplateFactory.load('ClassCreation.egl');
				t.populate ('currentElement', interface);	
				t.populate('currentPackage', pack);
				t.populate('currentModel', modelProject);  
				t.populate('path', path); 
				t.populate('isInterface', isInterface); 
				t.populate('bidirectionalRelations', bidirectionalRelations);  
				var path=directory + pack.name + "\\"+ interface.name +'.cs'; 
				t.generate (path); 	
				paths_notempty.add(path);
		     }//for-interface 
		}//if-classes-size 
	}//for-package
	
	// Save the multiple hierarchy tuples  
	var multipleHierarchyClasses = multipleHierarchyClasses(packages); 
	for (element in multipleHierarchyClasses){
		// Parents  
		var parents=element[0];
		// Child  
		var child=element[1]; 
		// Parents packages
		var parentsPackages=element[2]; 
		// Variable to iterate the parentsPackages
		var iter=0; 
		// Child package
		var childPackages=element[3];
		for (parent in parents){
			var path=directory + parentsPackages[iter].name + "\\Interface_"+ parent.name +'.cs';  
			// Need to create the appropiate interface 
			// Extract properties from the parent class
			var interfaceName="Interface_"+ parent.name;
			var properties=parent.propertiesGeneration(true, bidirectionalRelations, parentsPackages[iter].name, path);  
			// Extract methods from the parent class
			var methods=parent.classMethods(parentsPackages[iter].name, path); 
			// Create the interface (only implements the properties).
			var t := TemplateFactory.load('Classes/InterfaceCreation.egl');
			t.populate ('currentInterface', parent);	
			t.populate('currentPackage', parentsPackages[iter]);
			t.populate('currentModel', modelProject);  
			t.populate('currentProperties', properties[0]);      
			t.populate('currentAditionalMethods', properties[1]);   
			t.generate (path); 	
			paths_notempty.add(path); 
			// Create the class (only implements the methods). 
			var t := TemplateFactory.load('ClassCreationMultipleHierarchyCase.egl'); 
			t.populate ('currentElement', parent);	
			t.populate('currentPackage', parentsPackages[iter]);
			t.populate('currentModel', modelProject);  							
			t.populate('currentMethods', methods); 
			t.populate('currentParents', parent.hierarchy()); 
			t.populate('isInterface', false);      
			var path=directory + parentsPackages[iter].name + "\\"+ parent.name +'.cs';  
			t.generate (path); 	
			paths_notempty.add(path); 
			// Iterate the parentsPackages
			iter=iter+1;
		}//for-parents
		// Create the child class with as many collections as parents has, so it can access the methods.
		var path=directory+ childPackages.name + "\\"+ child.name +'.cs'; 
		var t := TemplateFactory.load('ChildClassHierarchyCase.egl'); 
		t.populate ('currentElement', child);	
		t.populate('currentPackage', childPackages);
		t.populate('currentModel', modelProject);  
		t.populate('currentParents', child.hierarchy());
		t.populate('path', path);
		t.populate('bidirectionalRelations', bidirectionalRelations);
		t.generate (path); 	
		paths_notempty.add(path); 
	}//for-element-multipleHierarchyClasses  
	// Set of two sets, one for empty and the other one for non empty paths
	var paths:List;
	paths.add(paths_empty);
	paths.add(paths_notempty);  
	return paths;
}
%]
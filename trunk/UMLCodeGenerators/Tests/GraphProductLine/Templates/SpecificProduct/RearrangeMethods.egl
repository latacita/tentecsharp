[%
////////////////////////////////////////////////////////////
//
// Author: Patricia Abascal Fernández
// Version: 1.2
// Last modification: 12/05/2013 
// Description: 
//////////////////////////////////////////////////////////// 
import "../SpecificProduct/SpecificProductOperations.eol";
operation rearrangeMethods(deepestVersions: Set, paths: List, packages:Set): Set{ 
	// Select the independent paths 
	for (thisPath in paths){
		// Excluding the source 
		// MAYBE CHANGE THIS WHEN EVERYTHING WORKS
		var otherPaths=paths.excluding(thisPath);
		thisPath=thisPath.excluding(thisPath[0]);  
		for (thisPack in thisPath){  
			for (otherPath in otherPaths){ 
				otherPath=otherPath.excluding(otherPath[0]); 
				// Dependent paths
				if (otherPath.contains(thisPack)){ 
					// Accesibility
					for (otherPack in otherPath){
						if (thisPack<>otherPack){ 
							var isAccessible = isAccessible(thisPack,otherPack,packages);
							// Extract the conflicts between packages
							var conflicts=conflictOpers(thisPack.name, otherPack.name, deepestVersions);
							// If is accesible
							if (isAccessible){
								var elements=extractOperationsFromGivenPackage(otherPack, conflicts);
								for(element in elements){
									deepestVersions=deepestVersions.excluding(element);
								}//for-element
							}else{
								var elements=extractOperationsFromGivenPackage(thisPack, conflicts);
								for(element in elements){
									deepestVersions=deepestVersions.excluding(element);
								}//for-element
							}//if-isAccessible
						}//if-thisPack
					}//for-otherPack
				}//if-otherPath
			}//for-otherPath
		}//for-thisPack
	}//for-thisPath 
	return deepestVersions;
}
%]
////////////////////////////////////////////////////////////
//
// Author: Patricia Abascal Fernández
// Version: 2.2
// Last modification: 12/04/2013 
// Description: Operations to use in templates.
////////////////////////////////////////////////////////////
 
// This operation puts first letter of the Feature name in upper case
operation Element firstToUpperCase() : String {
	return self.name.firstToUpperCase;
}
// This operation returns the text "virtual" to include in the method's header
operation virtual(): String { 
	return " virtual ";	
}
// This operation returns the text "void" to include in the method's header
operation void(): String { 
	return "void ";	
}
// This operation returns the text "private" to include in the property or method's header
operation private(): String { 
	return "private ";	
}
// This operation returns the text "public" to include in the property or method's header
operation public(): String { 
	return "public ";	
}
// This operation returns the text "override" to include in the property or method's header
operation override(): String { 
	return " override ";	
}
// This operation returns the text "static" to include in the property or method's header
operation static(): String { 
	return " static ";	
}
// This operation returns the text "abstract" if the element is abstract
operation Element abstract(): String { 
	var ab="";
	if (self.isAbstract){
		ab=" abstract ";
	} 
	return ab;	
} 
// This operation returns the text "readonly" to include in the property or method's header
operation readonly(): String { 
	return " readonly ";	
}
// This operation returns the text "static" if the property or method is static
operation Feature esStatic(): String { 
	var s;
	if (self.isStatic()){
		s=" static ";
	}
	return s;	
}
// This operation returns the text "readonly" if the property is readonly
operation Feature esReadonly(): String { 
	var s;
	if (self.isReadonly()){
		s=" readonly ";
	}
	return s;	
}
// This operation returns the text "int"
operation toInt(): String { 
	return " Int ";	
}
// This operation returns the element with the first letter in lower case 
operation Element firstToLowerCase(): String { 
	return self.name.firstToLowerCase();	
}
// This operation returns a lists of two elements:
// 		0: A boolean indicates if the type collection is supported or not
// 		1: The text corresponding to the type of collection for the given element
operation Element typeCollection(package: String, path: String): String { 
	var collection: String; 
		if (self.isOrdered and self.isUnique){
		    // It's a OrderedSet (rare case) 	
		    // Warning message because it's a rare case     
			var message="Warning: (Rare collection type):\n\t Found an unique and ordered collection named \""+self.name+ "\" from the package \"";
			message=message+package+"\"\n\t which is not supported, it was replaced by an IList collection.\n\n";  
			writeInFile(path+"\\log.txt", message);  
			collection="IList <"+self.type.name+">";  
		}
		if (self.isOrdered and not self.isUnique){
			// It's a List
			collection="IList <"+self.type.name+">"; 
		}
		if (not self.isOrdered and self.isUnique){
			// It's a classical set
			collection = "ISet <"+self.type.name+">"; 
		}
		if (not self.isOrdered and not self.isUnique){
			// It's a bag
			collection= "ICollection <"+self.type.name+">"; 
		} 
	return collection;	
}
// This operation returns a set of the parents of the current element
operation Element hierarchy (): Set{ 
	return self.generalization;
}
// This operation uses a Java Tool to create the empty directories
operation directory(path:String) {
	var sampleTool = new Native("pluginCreateDirectories.CreateDirectory");
	sampleTool.creation(path);	
}
// This operation returns the current path
operation path():String {
	var sampleTool = new Native("pluginCreateDirectories.CreateDirectory");
	return sampleTool.getPath();	
}
// This operation uses a Java Tool to create the window message
operation createWindow(message:String) {
	var sampleTool = new Native("pluginCreateMessageWindow.CreateMessageWindow");
	sampleTool.createMessageWindow(message);	
}
// This operation uses a Java Tool to create the error message window
operation createErrorWindow(message:String) {
	var sampleTool = new Native("pluginCreateMessageWindow.CreateMessageWindow");
	sampleTool.createErrorWindow(message);	
}
// This operation uses a Java Tool to create the save to disk dialog
operation createSaveToDiskWindow(): String {
	var sampleTool = new Native("pluginCreateSelectDiretoryWindow.CreateSelectDirectoryWindow");
	return sampleTool.createSelectDirectoryWindow();	
}
// This operation uses a Java Tool to add info to the log file
operation writeInFile(path:String, message:String) {
	var sampleTool = new Native("pluginWriteInFile.WriteInFile");
	sampleTool.writeInFile(path, message);	
}
// This operation uses a Java Tool to delete the log file
operation deleteFile(path:String, message:String) {
	var sampleTool = new Native("pluginWriteInFile.WriteInFile");
	sampleTool.deleteFile(path, message);	
}
// This operation uses a Java Tool to check if a file exists
operation fileExists(path:String): Boolean{
	var sampleTool = new Native("pluginWriteInFile.WriteInFile");
	return sampleTool.fileExists(path);	
}
// This operation uses a Java Tool to create a window and show the log info
operation createWindowAndShowMessages(path:String): String {
	var sampleTool = new Native("pluginCreateWindowAndShowMessages.CreateWindowAndShowMessages");
	return sampleTool.createWindowAndShowMessages(path);
} 
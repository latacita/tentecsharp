%%==========================================================================%%
%% Author : Abascal Fernández, Patricia                                     %%
%% Author : Sánchez Barreiro, Pablo                                         %%
%% Version: 1.2, 21/04/2013                                                 %%
%%                                                                          %%
%% Memoria del Proyecto Fin de Carrera                                      %%
%% Domain Engineering/Ejemplo de Generación de Código C#: Caso Sencillo     %%
%%==========================================================================%%
Para introducir al lector en la implementación de los generadores de código, vamos a analizar en detalle uno de los generadores de código más sencillos: \imp{MethodsCreation}, el fichero fuente aparece en el listing \ref{dom:code:method}. Vamos a proceder al análisis detallado del mismo:
\begin{itemize}
  \item Líneas 1-3, generadores de código que utiliza y fichero \imp{Operations.eol} que contiene las funciones básicas comunes a los generadores de código.
  \item Línea 4, descripción de la función que retornará el texto generado.
  \item Línea 6, se realiza una llamada a la función encargada de generar el constructor para la clase o interfaz y se guarda su valor en la variable \imp{opers}.
  \item Líneas 8-22, tratamos una a una todas las operaciones descritas en elemento actual (clase o interfaz).
  \item Líneas 9-22, en cada operación recorremos todos y cada uno de sus parámetros.
  \item Líneas 11-13, si la operación no tiene definido un tipo, es decir, si el usuario ha obviado especificar si la función devuelve una colección, un entero, un elemento de una clase, etc, por defecto se trata como una operación void (operación que no retorna ningún valor).
  \item Línea 14, si la operación tiene un tipo de retorno definido, se realiza una llamada a la función \imp{isReturn} que devolverá un booleano indicando si dicho parámetro es de retorno.
  \item Línea 17-19, si la operación que está siendo analizada retorna un valor, se añade a la lista de operaciones que devuelven un valor.
  \item Línea 20, si la operación que está siendo analizada no retorna un valor, se añade a la lista de operaciones que no devuelven un valor.
  \item Línea 23-26, añadir al string resultado la información correspondiente a los métodos de la clase actual que no retornan ningún valor (métodos void).
  \item Línea 24, se realiza una llamada a la función \imp{methodName}, en caso de que el método no tenga un nombre definido  se otorga un nombre por defecto.
  \item Línea 25, se llama a la función \imp{voidOperation} para obtener la declaración completa del método.
  \item Línea 27-30, de manera análoga a las operaciones que no retornan ningún valor, se procede a añadir al string resultado los métodos de la clase que sí retornan un valor.
  \item Línea 32, se retorna el string con todos los métodos de la clase o interfaz actual.
\end{itemize}

\begin{lstlisting} [basicstyle=\ttfamily\scriptsize,language=CSharp, captionpos=b,
                    caption=Implementación del generador de código \imp{MethodsCreation},
                    label=dom:code:method]
01 [%import "ReturnParameterCreation.egl";
02 import "ParametersCreation.egl";
03 import "../Operations.eol";
04 operation Element classMethods(currentPackage: String, path: String)
                     : String {   		
05  ...
06  opers=self.generatePartialConstructor (currentPackage);
07  ...
08  for (oper in self.getOperations()){
09      for (par in oper.ownedParameter){
10          ...	
11          if (oper.type==null){
12              isReturn=false;
13          }else{
14                isReturn=par.isReturn();
15          }//if-oper-type
16      }//for-parameters
17      if (isReturn){
18          operations_return.add(oper);
19      }else{
20          operations_void.add(oper);
21      }//if-isReturn		
22  }//for-operations	
23  for (oper in operations_void) {
24       methodname=oper.methodName();
25       opers=opers+oper.voidOperation(currentPackage, methodname, path);
26  }
27  for (oper in operations_return) {
28      methodname=oper.methodName();
29      opers=opers+oper.returnOperation(currentPackage, methodname, path);
30  }
32  return opers;
32 }%]
\end{lstlisting}

%Un vez explicado un ejemplo sencillo, la siguiente sección \ref{domain:sec:ejcomplejo} explica ejemplos más complejos que quedan a la curiosidad del lector.

Para utilizar una \emph{Java Tool} en Epsilon es necesario \emph{envolver} las funciones Java en funciones EOL. El Listado~\ref{dom:code:writeinfile} muestra un ejemplo de dicho proceso de envoltura.

\begin{lstlisting} [basicstyle=\ttfamily\scriptsize,language=CSharp, captionpos=b,
                    caption=Uso de un Java Tool en los generadores de código,
                    label=dom:code:writeinfile]
File Operations.eol
--------------------------------------------------------
01 operation writeInFile(path:String, message:String) {
02     var sampleTool = new Native("pluginWriteInFile.WriteInFile");
03     sampleTool.writeInFile(path, message);	
04}
\end{lstlisting}

Una vez explicado este sencillo ejemplo, damos por concluida la etapa de implementación de los generadores de código para la parte de \emph{Ingeniería del Dominio}, el siguiente paso es la realización de las pruebas pertinentes para comprobar el correcto funcionamiento de los mismos, la siguiente sección \ref{domain:sec:pruebas} muestra cómo se desarrolla dicha etapa.


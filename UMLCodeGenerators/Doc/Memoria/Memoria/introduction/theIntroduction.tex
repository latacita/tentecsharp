%%==================================================================%%
%% Author : Tejedo González, Daniel                                 %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 14/11/2012                                         %%
%% Version: 1.0, 21/01/2013                                         %%
%%                                                                  %%    
%% Memoria del Proyecto Fin de Carrera                              %%
%% Introducción/Introducción                                        %% 
%%==================================================================%%

El principal objetivo de este Proyecto de Fin de Carrera es extender la herramienta \emph{Hydra}~\cite{} para que soporte la especificación y validación de restricciones que contengan características con cardinalidad. Dicho objetivo resultará, como es lógico, confuso para el lector no familiarizado con las líneas de productos software~\cite{} en general, y con los árboles de características con cardinalidad~\cite{}, en particular. Por tanto, intentaremos introducir de forma breve al lector en estos conceptos.

%%=================================================================%%
%% NOTA(Pablo) : Demasiado complejo y poco claro
%%=================================================================%%
%%
%% continuar el desarrollo de la herramienta Hydra allá dónde
%% se dejó. Pero para entender un poco mejor las características
%% del entorno que aquí se ha desarrollado conviene explicar un
%% poco las razones que motivaron la creación del proyecto Hydra
%% en primera instancia. Desde su nacimiento, Hydra ha pretendido
%% convertirse en la aplicación más completa para trabajar con
%% Líneas de Producto Software, dado que no existe ninguna que
%% ofrezca una serie de características de manera conjunta.
%% Trabajar con Líneas de productos software conlleva a su vez
%% trabajar con una nada desdeñable cantidad de conceptos
%% íntimamente vinculados a ellas. En los próximos párrafos se
%% describirá lo que es una línea de productos software y los
%% conceptos subyacentes que nos permiten trabajar con ellas.
%%
%%=================================================================%%

El objetivo de una \emph{Línea de Productos Software}~\cite{} es crear la infraestructura adecuada para una rápida y fácil producción de sistemas software similares, destinados a un mismo segmento de mercado. Las líneas de productos software se pueden ver como análogas a las líneas de producción industriales, donde productos similares o idénticos se ensamblan y configuran a partir de piezas prefabricadas bien definidas. Un ejemplo clásico de línea de producción industrial es la fabricación de automóviles, donde se pueden crear decenas de variaciones de un único modelo de coche con un solo grupo de piezas cuidadosamente diseñadas mediante una línea de montaje específicamente diseñada para configurar y ensamblar dichas piezas.

Ya dentro del mundo del software, el desarrollo de software, por ejemplo, para teléfonos móviles implica la creación de productos con características muy parecidas, pero diferenciados entre ellos. Por ejemplo, una aplicación de agenda personal podrá ofrecer diferentes funcionalidades en función de si el terminal móvil posee GPS (\emph{Global Positioning System}), acceso a mapas o \emph{bluetooh}. Por tanto, el objetivo de una línea de productos software es crear una especie de línea de montaje donde una aplicación de agenda personal como la mencionada se pueda construir de la forma más eficiente posible de acuerdo a las características concretas de cada terminal específico.

Para construir una línea productos software, el primer paso es analizar qué características comunes y variables poseen cada uno de los productos que tratamos de producir. Para realizar dicho análisis de la variabilidad de una familia de productos se utilizan diversas técnicas. Las más utilizadas actualmente son la creación de árboles de características~\cite{} y los lenguajes específicos de dominio~\cite{}. En este proyecto nos centraremos en la primera opción.

Un árbol de características~\cite{} es un tipo de modelo que especifica, tal como su nombre indica en forma de árbol, las características que puede poseer un producto concrete perteneciente a una familia de productos, indicando qué características son comunes a todos los productos, cuáles son variables, así como las razones por las cuales son variables.

Por ejemplo, en una línea de productos de agendas personales para teléfonos móviles, toda agenda personal debe permitir anotar eventos a los que debemos asistir en un futuro cercano. Por tanto, esta característica sería una característica obligatoria para todas las agendas personales. Sin embargo, ciertas agendas, dependiendo del precio que el usuario final esté dispuesto a pagar y las características técnicas de cada terminal, podrían ofrecer la función de geolocalizar el lugar del evento al que debemos asistir, y calcular la ruta óptima desde el lugar que le indiquemos a dicho lugar de destino. Esta última característica sería opcional, y podría no estar incluida en ciertas agendas personales instalados en terminales concretos.

Para obtener un producto específico dentro de una línea de productos software, el cliente debe especificar qué características concretas desea que posea el producto que va a adquirir. Es decir, en términos técnicos, debe crear una \emph{configuración} del árbol características. Obviamente, no toda selección de características da lugar a una configuración válida. Por ejemplo, toda configuración debe contener al menos el conjunto de características que son obligatorias para todos los productos. De igual forma, puede ser obligatorio escoger al menos una características de entre una serie de alternativas. Por ejemplo, la agenda personal podría estar disponible en castellano, inglés y francés. En este caso sería posible seleccionar cualquiera de las tres alternativas, pero al menos una debería incluirse en nuestro producto. También sería posible indicar que podemos seleccionar un único idioma, es decir, que no podemos instalar una agenda personal que soporte de forma simultánea dos idiomas distintos.

La mayoría de estas restricciones se pueden especificar usando la sintaxis propia de los árboles de características. No obstante, existen una serie de restricciones que no se pueden modelar con la sintaxis propia de los árboles de características. Un ejemplo de tal tipo de restricción son las relaciones de dependencias entre características. Por ejemplo, la selección de una característica de cálculo de rutas óptimas podría necesitar para funcionar que  estuviesen instalados los servicios de mapas y geolocalización. Dichas tres características podrían no aparecer relacionadas en el árbol de características, por lo que tendríamos que definir dicha restricción como una restricción externa.

Estas restricciones externas se suelen especificar utilizando fórmulas de lógica proposicional~\cite{}. Los átomos de dichas fórmulas son las características del sistema. Dichos átomos se evalúan a verdadero si las características correspondientes están seleccionadas, y a falso en caso contrario. Por ejemplo, la restricción anteriormente expuesta podría especificarse como $CalculoRutasOptimas \Rightarrow (Mapas \wedge Geolocalizacion)$.

Para que estas restricciones sean utilidad, además de especificarlas, debemos comprobar que satisfacen para las diferentes configuraciones creadas. En los últimos años se han ido creando diversas técnicas y herramientas para el análisis y validación de dichas restricciones~\cite{}.

Paralelamente al problema de la especificación y validación de las restricciones externas, se han ido incorporando diversas modificaciones y novedades a los modelos de árboles de características en los últimos años. Por ejemplo, se han introducido conceptos como las \emph{referencias entre características}~\cite{} y \emph{atributos}~\cite{} para las características. Uno de estos conceptos, simple pero importante, ha sido el de  característica clonable~\cite{}. Una característica clonable es una características que pueden aparecer un número variable de veces dentro de un producto.

Por ejemplo, supongamos que tenemos una red de sensores para la monitorización y regulación del nivel de humedad de un determinado recinto, por ejemplo, de un invernadero. Dependiendo de donde fuésemos a instalar dicha red, podríamos necesitar un número diferente de sensores. Además, dependiendo de donde instalásemos cada sensor, podríamos configurar cada sensor de forma diferente. Por ejemplo, ciertos sensores podrían necesitar tener capacidades de enrutamiento, se tolerantes a fallo o poseer modos de hibernación para disminuir el consumo de energía. Por tanto, en dicho sistema sería interesante modelar \emph{Sensor} como una característica que se puede clonar, es decir, crear un número variable de instancias de la misma, y donde cada clon fuese a su vez configurable con ciertas características.

La incorporación de las características clonables a los árboles de características hace que los mecanismos utilizados hasta ahora para especificar y evaluar restricciones externas hayan quedado obsoletos. Dado que las características clonables no se seleccionan sino que se clonan, ya no podemos evaluar una característica clonable a verdadero o falso dependiendo de si está o no seleccionada. El concepto de \emph{estar seleccionada} desaparece en el caso de las características clonables.

Para solventar dicho problema, el profesor Pablo Sánchez, dentro del Departamento de Matemáticas, Estadística y Computación, ha desarrollado un nuevo lenguaje para la especificación y validación de restricciones externas a los árboles de características donde dichas restricciones pueden contener \emph{características clonables}. Dicho lenguaje se denomina \emph{HCL (Hydra Constraint Language}).

El objetivo de este Proyecto Fin de Carrera es implementar un editor que permita especificar y validar restricciones especificadas en HCL, es decir restricciones sobre árboles de características que puedan incluir características clonables. Dicho editor se debe integrar en una herramienta para el modelado y configuración de árboles de características denominada \emph{Hydra}, desarrollada también por el profesor Pablo Sánchez, en colaboración con un antiguo alumno suyo de la Universidad de Málaga, José Ramón Salazar. Con esto esperamos haber aclarado el primer párrafo de esta sección al lector no familiarizado con las líneas de productos software y/o los árboles de características.

Hydra se distribuye actualmente como un plugin para Eclipse, y ha sido desarrollada utilizando modernas técnicas de \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{}. Dichas técnicas permiten una rápida y cómoda creación de entornos de edición y evaluación de lenguajes tanto visuales como textuales mediante la especificación de una serie de elementos básicos a partir de los cuales se genera una gran cantidad de artefactos, reduciendo los tiempos de desarrollo y costo asociado al desarrollo de dichos entornos. El editor desarrollado en este Proyecto Fin de Carrera deberá distribuirse también como un plugin para Eclipse, instalable sobre \emph{Hydra}. Para su desarrollo se usará también un enfoque de \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{}.

Tras esta introducción, el resto del presente capítulo se estructura como sigue: La Sección~\ref{sec:intr:sle} proporciona unas nociones básicas sobre la \emph{Ingeniería de Lenguajes Dirigida por Modelos}, nociones que son necesarias para poder entender la planificación del presente proyecto, la cual se describe en la Sección~\ref{sec:intr:planning}. Por último, la Sección~\ref{sec:intr:estructura} describe la estructura general del presente documento.
%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 17/06/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Background/Slicer Pattern                                        %%
%===================================================================%%

El mecanismo utilizado por la metodología Te.Net para gestionar la variabilidad de una línea de productos a nivel de código es el \emph{Slicer Pattern}~\citep{perez:2011}. Dicho patrón se basa fuertemente en el concepto de clases parciales existente en C\#. Por tanto, antes de proceder a la descripción de dicho patrón, introduciremos al lector en el concepto de clase parcial. Más concretamente, nos centraremos en el concepto de clase parcial proporcionado por C\#.

Las clases parciales de C\#~\citep{albahari:2010} permiten dividir la implementación de una clase en varios archivos de código fuente. Cada fragmento representa una parte de la funcionalidad global de la clase. Todos estos fragmentos se combinan, en tiempo de compilación, para crear una única clase, la cual contiene toda la funcionalidad especificada en las clases parciales.

Por lo tanto, las clases parciales C\# parecen un mecanismo adecuado para implementar características, tal como ha sido identificado por diversos autores~\cite{laguna:2007,laguna:2010}. La idea es que cada incremento en funcionalidad perteneciente a una característica se podría encapsular en una clase parcial separada. Cuando un cliente solicita un producto con una serie de características concretas, se combinarían (compilarían) las clases parciales correspondientes a esas características. Esto daría lugar a un producto que contendría única y exclusivamente las características seleccionadas.

Ilustramos esta idea con un ejemplo basado en el caso de estudio del presente proyecto, expuesto en la Figura~\ref{back:fig:smartHome}. La Figura~\ref{back:code:partialClasses} muestra un ejemplo donde las clases parciales se aplican a la implementación de la clase \imp{Gateway}. La implementación de esta clase para las caracterísiticas \imp{HeaterMng} y \imp{SmartEnergyMng} ha sido separada en dos ficheros (Figura~\ref{back:code:partialClasses} líneas 0-8 y líneas 9-15) con el mismo nombre, pero emplazados en distintos directorios (\imp{HeaterMng/Gateway.cs} y \imp{SmartEnergyMng/Gateway.cs}). La clase \imp{Gateway} para la característica \imp{HeaterMng} (Figura~\ref{back:code:partialClasses} líneas 0-8) contiene una colección para controladores de temperatura (línea 2), al igual que el método \imp{heaterAdjustTemperature} (línea 4), acorde al modelo de la Figura~\ref{back:fig:smartHome}. La clase \imp{Gateway} para la característica \imp{SmartEnergyMng} (Figura~\ref{back:code:partialClasses} líneas 9-15) contiene los métodos \imp{adjustTemperature} (línea 12), \imp{findEmptyTime} (línea 13) y  \imp{checkTime} (línea 14).

La Figura~\ref{back:code:partialClasses} (líneas)

   
Figure 3 (lines 17-27) shows a build file (SmartHome.csproj) for this project. This
file indicates the Gateway partial classes for the InitialModel and the LightMng features
must be included in the compilation unit; but the corresponding partial classes for
the WindowMng and the SmartEnergyMng features must be excluded. Therefore, the
compiler will produce a Gateway class with functionality to manage lights, but not to
manage windows or heaters.
Motivated by these results, some authors, such as Laguna et al (Laguna et al.,
2007; Laguna and Marqu´es, 2010), proposed to used C# partial classes to implement
feature-oriented designs. Next section will evaluate this idea, showing these initial
results are not promising as they might seem.


\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
File HeaterMng/Gateway.cs
--------------------------------------------------------
0 namespace SmartHome {
1    public partial class Gateway {
2    private ISet <HeaterCtrl> heaterCtrl;
3
4       public void heaterAdjustTemperature (Int id, double temp) {...}
7    }
8 }

File SmartEnergyMng/Gateway.cs
--------------------------------------------------------
9 namespace SmartHome {
10     public partial class Gateway { 
11
12     public void adjustTemperature (Int id_heater, double temperature) {...}
13     protected void findEmptyTime ( ) {...}
14     protected void checkTime ( ) {...}
15 }

File SmartHome.csproj
--------------------------------------------------------
16 </Project>
17 ...
18 <ItemGroup>
19 <Compile Include="BaseSystem\Gateway.cs" />
20 <Compile Include="HeaterMng\Gateway.cs" />
21 <!-- <Compile Include="WindowMng\Gateway.cs" />
22 <!-- <Compile Include="LightMng\Gateway.cs" />
23 <Compile Include="SmartEnergyMng\Gateway.cs" />
24 -->
25 ...
26 </ItemGroup>
27 </Project>
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Ejemplo de operación EOL}
\label{back:code:partialClasses}
\end{figure}
%%==================================================================%%
%% NOTA(Pablo): Mete aquí un ejemplo simple de como se divide       %%
%%              el código de las clases parciales utilizando        %%
%%              características.                                    %%
%%              Copia y pega del artículo que se llama              %%
%%              "Implementing Feature-Oriented Decompositions       %%
%%               Using C# Partial Classes: An Exploratory Study"    %%
%%               el cual te mando por correos.                      %%
%%              Si te hacen falta las fuentes me las pides          %%
%%              El ejemplo debe corresponderse con el modelo UML    %%
%%              que sale en la sección de
%%==================================================================%%

Sin embargo, de acuerdo a una serie de experimentos realizados por Sánchez et al~\citep{}, las clases parciales tienen un serio inconveniente a la hora de implementar características. Utilizando clases parciales, no podemos ni sobreescribir ni extender métodos ya existentes dentro de una clase parcial. Ilustramos este problema con un ejemplo.

%%==================================================================%%
%% NOTA(Pablo): Mete aquí un ejemplo simple que ilustre el problema %%
%%              en sí. Lo puedes copiar del propio artículo que     %%
%%              describe el Slicer Pattern                          %%
%%                                                                  %%
%%==================================================================%%

El \emph{Slicer Pattern} surge como solución para resolver estas limitaciones. Para ello, el \emph{Slicer Pattern} se basa en la siguiente idea: dado que el problema es que no podíamos tener métodos con el mismo nombre en diferentes clases parciales, la solución consiste en añadir un prefijo a cada método, de forma que cada método tenga un nombre diferente. Dicho prefijo será el nombre de la características a la cual pertenece la clase parcial que contiene cada método.

La Figura~\ref{back:fig:slicerPattern} muestra como el ejemplo de la Figura~\ref{} ha sido refactorizado siguiendo dicha idea.

%%==================================================================%%
%% NOTA(Pablo): El ejemplo debe casar con el anterior. Cuando lo    %%
%%              tengas listo, sigo mirando desde aquí,              %%
%%              que necesito saber como casa todo                   %%
%%                                                                  %%
%%==================================================================%%

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.95\linewidth]{background/images/slicerPattern.eps} \\
  \caption{Proceso de Desarrollo de una Línea de Productos Software}
  \label{back:fig:slicerPattern}
\end{figure}

Usando esta estrategia se puede comprobar cómo, por ejemplo, las versiones del método \imp{thermometerChanged} correspondientes a las características \imp{HeaterMng} y \imp{SmartEnergyMng} han sido transformadas en \imp{heaterMng\_thermometerChanged} y \imp{smartEnergyMng\_thermometerChanged} respectivamente y por tanto pueden co-existir sin que sus nombres colisionen. Es más, el método \imp{smartEnergyMng\_thermometerChanged} puede extender del método \imp{heaterMng\_thermometerChanged}. Se dispone por tanto de varias versiones parciales de un mismo método.

Para generar un producto específico es necesario que, a nivel de Ingeniería de Aplicación, se cree la denominada "versión limpia" del método \imp{thermometerChanged}, es decir, sin el prefijo. Mientras que las versiones de dicho método creadas en el nivel de Ingeniería del Dominio que han sido prefijadas con el nombre de la característica a la que cada método pertenece pasarán a ser denominadas "versiones sucias" de dicho método. Además, para asegurar que se invoca la versión correcta del método, no se deberían poder invocar los métodos \imp{heaterMng\_thermometerChanged} y \imp{smartEnergyMng\_thermometerChanged} directamente y por dicha razón todas las versiones sucias de los métodos son privadas. De dicha forma los objetos de las demás clases sólo podrán invocar a la versión limpia del método y dicha versión, redireccionará la llamada a las versiones sucias de los métodos correspondientes de acuerdo a las características seleccionadas.

Sin embargo este patrón no puede ser utilizado para los constructores de la clase ya que los constructores no se pueden renombrar porque deben tener un nombre específico. De esta forma, la instanciación del Patrón Slicer en los constructores se realiza de forma diferente a la instanciación del resto de métodos. De esta forma, cada clase parcial X correspondiente a una caracterísica F tendrá un método privado llamado $<$F$>$\_init\_$<$X$>$ que contendrá el fragmento de la lógica del constructor correspondiente a la característica F.

La Figura~\ref{back:code:constSlicerPattern} muestra cómo se aplica dicha técnica. Se puede apreciar cómo la lógica del constructor para \emph{Gateway} ha sido encapsulada en un método llamado  \imp{baseSystem\_initGateway} (Figura~\ref{back:code:constSlicerPattern} líneas 03-06). La misma técnica ha sido usada en la Figura~\ref{back:code:constSlicerPattern} líneas 10-12 con la característica \imp{WindowMng}. El siguiente paso es encontrar un mecanismo que permita componer dichos fragmentos de acuerdo a una selección de  características dada, de esta forma, como se puede apreciar en la Figura~\ref{back:code:constSlicerPattern} líneas 16-20, el constructor para la clase Gateway es creado con las características seleccionadas por el usuario final, en el caso analizado, por ejemplo, solo se ha seleccionado la característica \imp{WindowMng}.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
File BaseSystem/Gateway.cs
--------------------------------------------------------
01 public partial class Gateway {
02      ...
03      private void BaseSystem_initGateway() {
04          this.floors = new List<Floors>();
05          this.interfaces = new List<CentralGUI>();
06      }
07 }

File WindowMng/Gateway.cs
--------------------------------------------------------
08 public partial class Gateway {
09      ...
10      private windowMng_initGateway() {
11          this.windows = new List<Window>();
12      }
13 }

File MyHouse/Gateway.cs
--------------------------------------------------------
14 public partial class Gateway {
15      ...
16      public Gateway() {
17          // WindowMng has been selected
18          baseSystem_initGateway();
19          windowMng_initGateway();
20      }
21 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Código para el constructor de la clase Gateway usando clases parciales y patrón slicer}
\label{back:code:constSlicerPattern}
\end{figure}

Concluyendo con el Patrón Slicer, tanto los métodos regulares como con los constructores pueden ser extendidos y reescritos usando dicho patrón y solucionando así las limitaciones ofrecidas por el uso de clases parciales~\cite{sanchez:2010} como mecanismo de soporte orientado a características. Utilizando todo lo expuesto en las secciones anteriores, en la siguiente sección se expone a grandes rasgos el funcionamiento de los generadores de código que serán empleados durante la fase de Ingeniería del Dominio del presente proyecto.

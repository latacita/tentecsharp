%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 18/06/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Background/Generación de Código con Epsilon                      %%
%===================================================================%%

Epsilon~\cite{kolovos:2008} es una \emph{suite} de lenguajes y herramientas para el desarrollo software dirigido por modelos. En este sentido, Epsilon ofreces lenguajes para la transformación de modelo a modelo, modelo a texto, navegación a través de modelos o generación de editores textuales y/o gráficos para modelos, entre otras características. Epsilon se distribuye actualmente como un plug-in para Eclipse. El presente proyecto se ha centrado en la generación de código, para lo cual se han utilizado los lenguajes \emph{Epsilon Generation Language} (EGL)~\citep{dimitrios:2012}, que es el lenguaje de generación de código proporcionado por Epsilon; y \emph{Epsilon Object Language} (EOL)~\citep{dimitrios2:2012}, que es el lenguaje básico para la manipulación y navegación a través de modelos proporcionado por Epsilon. Describimos estos lenguajes en las siguiente subsecciones.

\subsection{Epsilon Object Language(EOL)}

El principal objetivo de EOL es proporcionar un lenguaje para la manipulación a nivel de código para la gestión de modelos. EOL proporciona facilidades para cargar un modelo, navegar a través de sus elementos o leer los valores de sus elementos, entre otras cracterísticas.

La Figura~\ref{back:code:eol} muestra un ejemplo del funcionamiento de EOL. EOL no es un lenguaje orientado a objetos en el sentido de que no permite definir clases. Sin embargo, EOL permite gestionar objetos de tipos o clases externamente definidos, normalmente dentro del metamodelo o gramática que define un lenguaje de modelado.

%%=======================================================================================================%%
%% [DONE]                                                                                                %%
%% NOTA(Pablo): Este ejemplo resulta demasiado sencillo. Prueba a hacer una función, por ejemplo, que    %%
%%              devuelva true si una clase UML tiene más de un padre, es decir, está afectada por la     %%
%%              herencia múltiple                                                                        %%
%%              La descripción es buena, haz la nueva de ese estilo                                      %%
%%=======================================================================================================%%

En la Figura~\ref{back:code:eol} línea 4, en este caso los objetos son de tipo Class. La línea 1 de la
 Figura~\ref{back:code:eol} presenta un ejemplo de llamada a operaciones EOL, donde el elemento \imp{clase}, de tipo Class, llama a la operación hasParent() y devuelve, tal como se aprecia en la línea 9, el valor de \emph{hasParent} que será true o false dependiendo de si la clase a analizar presenta herencia, si es clase hija de otra clase, o no. Dicho contenido se imprime por pantalla tal como se aprecia en la línea 2 mediante la instrucción \emph{println()}).

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
1 var bol = clase.hasParent();
2 bol.println();
3
4 operation Class hasParent (): Boolean{
5   var hasParent= false;
6   if (not self.generalization.isEmpty()){
7       hasParent=true;
8   }
9   return hasParent;
10 }	
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Ejemplo de operación EOL}
\label{back:code:eol}
\end{figure}

De esta forma, EOL permite definir funciones auxiliares para la manipulación o gestión de modelos. Estas funciones pueden ser utilizadas desde otros lenguajes de la suite Epsilon. En nuestro caso, estas funciones auxiliares se invocan desde el lenguaje
de transformación modelo a texto EGL, el cual se describe a continuación.

\subsection{Epsilon Generation Language(EGL)}

EGL es un lenguaje de transformación modelo a texto (\emph{model-to-text-transformation}). EGL puede ser tulizad para transformar modelos en diversos tipos de artefactos de carácter textual, incluyendo código (por ejemplo, Java), informes (por ejemplo, en HTML), imágenes (por ejemplo, gráficos SVG), especificaciones formales (por ejemplo, en el lenguaje Z), o incluso aplicaciones completas generadas con múltiples lenguajes (por ejemplo, HTML, Javascript, CSS, Java y SQL). En nuestro caso, utilizaremos EGL para la generación de código C\# desde modelos UML.

EGL es un generador de código basado en plantillas. Dichas plantillas son similares a las utilizadas en la generación de páginas web dinámicas, al estilo de sistemas como JSP (\emph{Java Server Pages})~\citep{eric:2010} o PHP (\emph{PHP Hypertext Preprocessor})~\citep{mehdi:2013}.

Las Figuras~\ref{back:code:generacionClases}, \ref{back:fig:epsilonEGL} y~\ref{back:code:resultadogeneracionClases} muestran un ejemplo sencillo del funcionamiento de EGL. La Figura~\ref{back:code:generacionClases} contiene una sencilla plantilla que genera un listado de las clases que contiene un modelo UML. El texto situado dentro de los caracteres de escape \texttt{[\%} y \texttt{\%]} aparecer tal cual en la salida producida por la plantilla. El código situado entre dichos caracteres de escape es código EGL que gobierna el proceso de generación de código.

Por ejemplo, las líneas 1 y 3 declaran un bucle que recorre todas las clases contenidas en el modelo de entrada. En cada iteración, se procesa la línea 2, que genera automáticamente el texto fuera de los caracteres de escape (``El modelo contiene la clase: ''). A continuación, se añade a la salida, por medio del operador \emph{=}, el nombre de la clase \emph{c}, que corresponda con la iteración realizada.

La Figura~\ref{back:code:resultadogeneracionClases} muestra el resultado que produciría la plantilla de la Figura~\ref{back:code:generacionClases} para el modelo mostrado en la Figura~\ref{back:code:resultadogeneracionClases}.

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
1 [% for (c in Class.all) { %]
2 El modelo contiene la clase: [%=c.name%]
3 [% } %]
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Generación del nombre de cada Class contenida en un modelo de entrada}
\label{back:code:generacionClases}
\end{figure}

\begin{figure}[!tb]
  \centering
	\includegraphics[width=.95\linewidth]{background/images/epsilonEGL} \\
  \caption{Ejemplo de modelo de entrada para generación de código con EGL}
  \label{back:fig:epsilonEGL}
\end{figure}

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
1 El modelo contiene la clase: Persona
2 El modelo contiene la clase: Alumno
3 El modelo contiene la clase: Profesor
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Resultado de la generación del nombre de cada Class contenida en un modelo de entrada}
\label{back:code:resultadogeneracionClases}
\end{figure}

Obviamente, EGL no sólo nos permite realizar estas sencillas operaciones. Por ejemplo, se pueden encapsular porciones reutilizables de código EGL en entidades bien definidos denominados \emph{templates}. Un \emph{template} tiene una funcionalidad similares a la de una \emph{función} o \emph{procedimiento} de un lenguaje de programación convencional.

La Figura~\ref{back:code:generacionOperacion} muestra un ejemplo de template que sirve para generar la cabecera de una clase Java. La cabecera del template (línea 2) especifica que el template de aplica a objetos del tipo \emph{Class}, no precisando de ningún parámetro de entrada. La clase a la cual se aplica el template es un parámetro implícito de entrada a esta operación, a la cual se puede acceder a través del operador \emph{self}. Utilizando este operador, la línea 4 genera la cabecera de una calse java, de acuerdo a la visibilidad \emph{self.visibility} y nombre \emph{self.name} de la clase sobre la cual se invoca esta operación. Siendo $c$ un objeto de tipo \emph{Class}, invocar este template sería tan fácil como escribir \emph{c.getHeader()}.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
1 [% @template
2 operation Class getHeader() { %]
3 [%=self.visibility] class [%=self.name%] {}
4 [% } %]
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Ejemplo de template en EGL}
\label{back:code:generacionOperacion}
\end{figure}

Una vez explicados estos conceptos, estamos preparados para poder definir cómo se ha estructurado y desarrollado el presente Proyecto Fin de Carrera. Dicha planificación se presenta en la siguiente sección.

%%=====================================================================================================%%
%% NOTA(Pablo): Esto es interesante, pero se hace ya pesado, así que yo lo quitaría                    %%
%%=====================================================================================================%%

%Un \emph{template} proporciona tres utilidades básicas al desarrollador EGL:

%\begin{enumerate}
%	\item Un \emph{template} permite modularizar y reutilizar el código utilizado en un proceso de transformación modelo a texto.
%    \item Un \emph{template} permite al usuario definir de forma fácil el destino del texto generado.  En la Figura~\ref{back:code:template} (línea 3) muestra un ejemplo de invocación de un template, cuyo destino es un fichero de texto denonimado \emph{output.txt}
%     \item Y por último, proporciona un conjunto de operaciones que se usan para controlar el destino del texto generado. En la Figura~\ref{back:code:template} (línea 3) se muestra cómo se elige el fichero destino para almacenar el texto generado con la plantilla \emph{ClassNames.egl}.
% \end{enumerate}

% \begin{figure}[tb!]
% \begin{center}
% \begin{footnotesize}
% \begin{verbatim}
% 1 [%
% 2 var t : Template = TemplateFactory.load("ClassNames.egl");
% 3 t.generate("Output.txt");
% 4 %]
% \end{verbatim}
% \end{footnotesize}
% \end{center}
% \caption{Almacenar el nombre de cada Class en disco}
% \label{back:code:template}
% \end{figure}



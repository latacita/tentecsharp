%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 18/06/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Background/Generación de Código con Epsilon                      %%
%===================================================================%%

Epsilon~\citep{kolovos:2011} es una \emph{suite} de lenguajes y herramientas para el desarrollo software dirigido por modelos. En este sentido, Epsilon ofrece lenguajes para la transformación de modelo a modelo, modelo a texto, navegación a través de modelos o generación de editores textuales y/o gráficos para modelos, entre otras características. Epsilon se distribuye actualmente como un plug-in para Eclipse. El presente proyecto se ha centrado en la generación de código, para lo cual se han utilizado los lenguajes \emph{Epsilon Generation Language} (EGL)~\citep{rose:2008}, que es el lenguaje de generación de código proporcionado por Epsilon; y \emph{Epsilon Object Language} (EOL)~\citep{kolovos:2006}, que es el lenguaje básico para la manipulación y navegación a través de modelos proporcionado por Epsilon. Describimos estos lenguajes en las siguiente subsecciones.

\subsection{Epsilon Object Language (EOL)}

El principal objetivo de EOL es proporcionar un lenguaje de manipulación a nivel de código para la gestión de modelos. EOL proporciona facilidades para cargar un modelo, navegar a través de sus elementos o leer los valores de sus elementos, entre otras cracterísticas.

La Figura~\ref{back:code:eol} muestra un ejemplo del funcionamiento de EOL. EOL no es un lenguaje orientado a objetos en el sentido de que no permite definir clases. Sin embargo, EOL permite gestionar objetos de tipos o clases externamente definidos, normalmente dentro del metamodelo o gramática que define un lenguaje de modelado.

%%=======================================================================================================%%
%% [DONE]                                                                                                %%
%% NOTA(Pablo): Este ejemplo resulta demasiado sencillo. Prueba a hacer una función, por ejemplo, que    %%
%%              devuelva true si una clase UML tiene más de un padre, es decir, está afectada por la     %%
%%              herencia múltiple                                                                        %%
%%              La descripción es buena, haz la nueva de ese estilo                                      %%
%%=======================================================================================================%%

En la Figura~\ref{back:code:eol} línea 04, en este caso los objetos son de tipo Class. La línea 01 de la
 Figura~\ref{back:code:eol} presenta un ejemplo de llamada a operaciones EOL, donde el elemento \imp{clase}, de tipo Class, llama a la operación hasParent() y devuelve, tal como se aprecia en la línea 09, el valor de \imp{hasParent} que será true o false dependiendo de si la clase a analizar presenta herencia, si es clase hija de otra clase, o no. Dicho contenido se imprime por pantalla tal como se aprecia en la línea 02 mediante la instrucción \imp{println()}).

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01 var bol = clase.hasParent();
02 bol.println();
03
04 operation Class hasParent (): Boolean{
05   var hasParent= false;
06   if (not self.generalization.isEmpty()){
07       hasParent=true;
08   }
09   return hasParent;
10 }	
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Ejemplo de operación EOL}
\label{back:code:eol}
\end{figure}

De esta forma, EOL permite definir funciones auxiliares para la manipulación o gestión de modelos. Estas funciones pueden ser utilizadas desde otros lenguajes de la suite Epsilon. En nuestro caso, estas funciones auxiliares se invocan desde el lenguaje
de transformación modelo a texto EGL, el cual se describe a continuación.

\subsection{Epsilon Generation Language (EGL)}

EGL es un lenguaje de transformación modelo a texto (\emph{model-to-text-transformation}). EGL puede ser utilizado para transformar modelos en diversos tipos de artefactos de carácter textual, incluyendo código (por ejemplo, Java), informes (por ejemplo, en HTML), imágenes (por ejemplo, gráficos SVG), especificaciones formales (por ejemplo, en el lenguaje Z), o incluso aplicaciones completas generadas con múltiples lenguajes (por ejemplo, HTML, Javascript, CSS, Java y SQL). En nuestro caso, utilizaremos EGL para la generación de código C\# desde modelos UML.

EGL es un generador de código basado en plantillas. Dichas plantillas son similares a las utilizadas en la generación de páginas web dinámicas, al estilo de sistemas como JSP (\emph{Java Server Pages})~\citep{bergsten:2003} o PHP (\emph{PHP Hypertext Preprocessor})~\citep{mehdi:2013}.

Las Figuras~\ref{back:code:generacionClases}, \ref{back:fig:epsilonEGL} y~\ref{back:code:resultadogeneracionClases} muestran un ejemplo sencillo del funcionamiento de EGL. La Figura~\ref{back:code:generacionClases} contiene una sencilla plantilla que genera un listado de las clases que contiene un modelo UML. El texto situado fuera de los caracteres de escape \texttt{[\%} y \texttt{\%]} aparecerá tal cual en la salida producida por la plantilla. El código situado entre dichos caracteres de escape es código EGL que gobierna el proceso de generación de código.

Por ejemplo, las líneas 01 y 03 declaran un bucle que recorre todas las clases contenidas en el modelo de entrada. En cada iteración, se procesa la línea 02, que genera automáticamente el texto fuera de los caracteres de escape (``El modelo contiene la clase: ''). A continuación, se añade a la salida, por medio del operador \emph{=}, el nombre de la clase \emph{c}, que corresponda con la iteración realizada.

La Figura~\ref{back:code:resultadogeneracionClases} muestra el resultado que produciría la plantilla de la Figura~\ref{back:code:generacionClases} para el modelo mostrado en la Figura~\ref{back:code:epsilonEGL}.

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01 [% for (c in Class.all) { %]
02 El modelo contiene la clase: [%=c.name%]
03 [% } %]
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Generación del nombre de cada Class contenida en un modelo de entrada}
\label{back:code:generacionClases}
\end{figure}
\begin{figure}[!tb]
  \centering
	\includegraphics[width=.55\linewidth]{background/images/epsilonEGL.eps} \\
  \caption{Ejemplo de modelo de entrada para generación de código con EGL}
  \label{back:fig:epsilonEGL}
\end{figure}
\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01 El modelo contiene la clase: Persona
02 El modelo contiene la clase: Alumno
03 El modelo contiene la clase: Profesor
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Resultado de la generación del nombre de cada Class contenida en un modelo de entrada}
\label{back:code:resultadogeneracionClases}
\end{figure}

Obviamente, EGL no sólo nos permite realizar estas sencillas operaciones. Por ejemplo, se pueden encapsular porciones reutilizables de código EGL en entidades bien definidas denominados \emph{templates}. Un \emph{template} tiene una funcionalidad similar a la de una \emph{función} o \emph{procedimiento} de un lenguaje de programación convencional.

La Figura~\ref{back:code:generacionOperacion} muestra un ejemplo de template que sirve para generar la cabecera de una clase Java. La cabecera del template (línea 02) especifica que el template de aplica a objetos del tipo \imp{Class}, no precisando de ningún parámetro de entrada. La clase a la cual se aplica el template es un parámetro implícito de entrada a esta operación, a la cual se puede acceder a través del operador \imp{self}. Utilizando este operador, la línea 04 genera la cabecera de una clase java, de acuerdo a la visibilidad \imp{self.visibility} y nombre \imp{self.name} de la clase sobre la cual se invoca esta operación. Siendo $c$ un objeto de tipo \imp{Class}, invocar este template sería tan fácil como escribir \imp{c.getHeader()}.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01 [% @template
02 operation Class getHeader() { %]
03 [%=self.visibility] class [%=self.name%] {}
04 [% } %]
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Ejemplo de template en EGL}
\label{back:code:generacionOperacion}
\end{figure}


%%=====================================================================================================%%
%% NOTA(Pablo): Esto es interesante, pero se hace ya pesado, así que yo lo quitaría                    %%
%%=====================================================================================================%%

%Un \emph{template} proporciona tres utilidades básicas al desarrollador EGL:

%\begin{enumerate}
%	\item Un \emph{template} permite modularizar y reutilizar el código utilizado en un proceso de transformación modelo a texto.
%    \item Un \emph{template} permite al usuario definir de forma fácil el destino del texto generado.  En la Figura~\ref{back:code:template} (línea 3) muestra un ejemplo de invocación de un template, cuyo destino es un fichero de texto denonimado \emph{output.txt}
%     \item Y por último, proporciona un conjunto de operaciones que se usan para controlar el destino del texto generado. En la Figura~\ref{back:code:template} (línea 3) se muestra cómo se elige el fichero destino para almacenar el texto generado con la plantilla \emph{ClassNames.egl}.
% \end{enumerate}

% \begin{figure}[tb!]
% \begin{center}
% \begin{footnotesize}
% \begin{verbatim}
% 1 [%
% 2 var t : Template = TemplateFactory.load("ClassNames.egl");
% 3 t.generate("Output.txt");
% 4 %]
% \end{verbatim}
% \end{footnotesize}
% \end{center}
% \caption{Almacenar el nombre de cada Class en disco}
% \label{back:code:template}
% \end{figure}

Con este apartado, termina el proceso de formación y aprendizaje de los fundamentos, técnicas, lenguajes y herramientas necesarios para la realización del proyecto. Una vez adquirido este bagaje, se procedió a la definición de la planificación del proyecto.


%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.2, 17/06/2013                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Background/Slicer Pattern                                        %%
%===================================================================%%

El mecanismo utilizado por la metodología Te.Net para gestionar la variabilidad de una línea de productos a nivel de código es el \emph{Slicer Pattern}~\citep{perez:2011}. Dicho patrón se basa fuertemente en el concepto de clases parciales existente en C\#. Por tanto, antes de proceder a la descripción de dicho patrón, introduciremos al lector en el concepto de clase parcial. Más concretamente, nos centraremos en el concepto de clase parcial proporcionado por C\#.

Las clases parciales de C\#~\citep{albahari:2010} permiten dividir la implementación de una clase en varios archivos de código fuente. Cada fragmento representa una parte de la funcionalidad global de la clase. Todos estos fragmentos se combinan, en tiempo de compilación, para crear una única clase, la cual contiene toda la funcionalidad especificada en las clases parciales.

Por lo tanto, las clases parciales C\# parecen un mecanismo adecuado para implementar características, tal como ha sido identificado por diversos autores~\cite{laguna:2007,laguna:2010}. La idea es que cada incremento en funcionalidad perteneciente a una característica se podría encapsular en una clase parcial separada. Cuando un cliente solicita un producto con una serie de características concretas, se combinarían (compilarían) las clases parciales correspondientes a esas características. Esto daría lugar a un producto que contendría única y exclusivamente las características seleccionadas.

%%==================================================================%%
%% [DONE]                                                           %%
%% NOTA(Pablo): Mete aquí un ejemplo simple de como se divide       %%
%%              el código de las clases parciales utilizando        %%
%%              características.                                    %%
%%              Copia y pega del artículo que se llama              %%
%%              "Implementing Feature-Oriented Decompositions       %%
%%               Using C# Partial Classes: An Exploratory Study"    %%
%%               el cual te mando por correos.                      %%
%%              Si te hacen falta las fuentes me las pides          %%
%%              El ejemplo debe corresponderse con el modelo UML    %%
%%              que sale en la sección de
%%==================================================================%%

Ilustramos esta idea con un ejemplo basado en el caso de estudio del presente proyecto, expuesto en la Figura~\ref{back:fig:smartHome}. La Figura~\ref{back:code:partialClasses} muestra un ejemplo donde las clases parciales se aplican a la implementación de la clase \imp{Gateway}. La implementación de esta clase para las caracterísiticas \imp{BaseSystem} y \imp{LightMng} ha sido separada en dos ficheros (Figura~\ref{back:code:partialClasses} líneas 0-9 y líneas 10-15) con el mismo nombre, pero emplazados en distintos directorios (\imp{BaseSystem/Gateway.cs} y \imp{LightMng/Gateway.cs}). La clase \imp{Gateway} para la característica \imp{BaseSystem} (Figura~\ref{back:code:partialClasses} líneas 0-9) contiene colecciones para sensores y actuadores (líneas 2 y 3), al igual que los métodos \imp{initializeAll}, \imp{checkAll} y \imp{switchDown} (líneas 5-7), acorde al modelo de la Figura~\ref{back:fig:smartHome}. La clase \imp{Gateway} para la característica \imp{LightMng} (Figura~\ref{back:code:partialClasses} líneas 10-15) contiene la colección \imp{ligthCtrl} (línea 12) y el método \imp{adjustLigth} (línea 14).

La Figura~\ref{back:code:partialClasses} (líneas 16-28) muestra el fichero build (\imp{SmartHome.csproj}) para este proyecto. Ese fichero indica que las clases parciales para las características \imp{BaseSystem} y \imp{LightMng} deben ser incluídas en la unidad de compilación; pero las correspondientes clases parciales para las características \imp{BlindMng}, \imp{HeaterMng}, \imp{WindowMng} y \imp{SmartEnergyMng} deben ser excluídas. Por tanto, el compilador generará una clase \imp{Gateway} con la funcionalidad para controlar las lunes pero no para controlar las ventanas o las temperaturas.

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
File BaseSystem/Gateway.cs
--------------------------------------------------------
0 namespace SmartHome {
1    public partial class Gateway {
2       protected IList<Sensor> sensors;
3       protected IList<Actuator> actuators;
4
5       private void initializeAll ( ) {...}
6       private void checkAll ( ) {...}
7       private void switchDown ( ) {...}
8    }
9 }

File LightMng/Gateway.cs
--------------------------------------------------------
10 namespace SmartHome {
11     public partial class Gateway {
12        private ISet <LigthCtrl> ligthCtrl;
13
14        private void adjustLigth ( Int id, Int ligthing ) {...}
15 }

File SmartHome.csproj
--------------------------------------------------------
16 </Project>
17 ...
18 <ItemGroup>
19 <Compile Include="BaseSystem\Gateway.cs" />
20 <Compile Include="LightMng\Gateway.cs" />
21 <!-- <Compile Include="BlindMng\Gateway.cs" />
22 <Compile Include="HeaterMng\Gateway.cs" />
23 <Compile Include="WindowMng\Gateway.cs" />
24 <Compile Include="SmartEnergyMng\Gateway.cs" />
25 -->
26 ...
27 </ItemGroup>
28 </Project>
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación de la clase \imp{Gateway} usando clases parciales}
\label{back:code:partialClasses}
\end{figure}

Sin embargo, de acuerdo a una serie de experimentos realizados por Sánchez et al~\citep{sanchez:2010,perez:2011}, las clases parciales tienen un serio inconveniente a la hora de implementar características. Utilizando clases parciales, no podemos ni sobreescribir ni extender métodos ya existentes dentro de una clase parcial. Ilustramos este problema con un ejemplo.

%%==================================================================%%
%% NOTA(Pablo): Mete aquí un ejemplo simple que ilustre el problema %%
%%              en sí. Lo puedes copiar del propio artículo que     %%
%%              describe el Slicer Pattern                          %%
%%                                                                  %%
%%==================================================================%%

El \emph{Slicer Pattern} surge como solución para resolver estas limitaciones. Para ello, el \emph{Slicer Pattern} se basa en la siguiente idea: dado que el problema es que no podíamos tener métodos con el mismo nombre en diferentes clases parciales, la solución consiste en añadir un prefijo a cada método, de forma que cada método tenga un nombre diferente. Dicho prefijo será el nombre de la características a la cual pertenece la clase parcial que contiene cada método.

La Figura~\ref{back:fig:slicerPattern} muestra como el ejemplo de la Figura~\ref{} ha sido refactorizado siguiendo dicha idea.

%%==================================================================%%
%% NOTA(Pablo): El ejemplo debe casar con el anterior. Cuando lo    %%
%%              tengas listo, sigo mirando desde aquí,              %%
%%              que necesito saber como casa todo                   %%
%%                                                                  %%
%%==================================================================%%

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.95\linewidth]{background/images/slicerPattern.eps} \\
  \caption{Proceso de Desarrollo de una Línea de Productos Software}
  \label{back:fig:slicerPattern}
\end{figure}

Usando esta estrategia se puede comprobar cómo, por ejemplo, las versiones del método \imp{thermometerChanged} correspondientes a las características \imp{HeaterMng} y \imp{SmartEnergyMng} han sido transformadas en \imp{heaterMng\_thermometerChanged} y \imp{smartEnergyMng\_thermometerChanged} respectivamente y por tanto pueden co-existir sin que sus nombres colisionen. Es más, el método \imp{smartEnergyMng\_thermometerChanged} puede extender del método \imp{heaterMng\_thermometerChanged}. Se dispone por tanto de varias versiones parciales de un mismo método.

Para generar un producto específico es necesario que, a nivel de Ingeniería de Aplicación, se cree la denominada "versión limpia" del método \imp{thermometerChanged}, es decir, sin el prefijo. Mientras que las versiones de dicho método creadas en el nivel de Ingeniería del Dominio que han sido prefijadas con el nombre de la característica a la que cada método pertenece pasarán a ser denominadas "versiones sucias" de dicho método. Además, para asegurar que se invoca la versión correcta del método, no se deberían poder invocar los métodos \imp{heaterMng\_thermometerChanged} y \imp{smartEnergyMng\_thermometerChanged} directamente y por dicha razón todas las versiones sucias de los métodos son privadas. De dicha forma los objetos de las demás clases sólo podrán invocar a la versión limpia del método y dicha versión, redireccionará la llamada a las versiones sucias de los métodos correspondientes de acuerdo a las características seleccionadas.

Sin embargo este patrón no puede ser utilizado para los constructores de la clase ya que los constructores no se pueden renombrar porque deben tener un nombre específico. De esta forma, la instanciación del Patrón Slicer en los constructores se realiza de forma diferente a la instanciación del resto de métodos. De esta forma, cada clase parcial X correspondiente a una caracterísica F tendrá un método privado llamado $<$F$>$\_init\_$<$X$>$ que contendrá el fragmento de la lógica del constructor correspondiente a la característica F.

La Figura~\ref{back:code:constSlicerPattern} muestra cómo se aplica dicha técnica. Se puede apreciar cómo la lógica del constructor para \emph{Gateway} ha sido encapsulada en un método llamado  \imp{baseSystem\_initGateway} (Figura~\ref{back:code:constSlicerPattern} líneas 03-06). La misma técnica ha sido usada en la Figura~\ref{back:code:constSlicerPattern} líneas 10-12 con la característica \imp{WindowMng}. El siguiente paso es encontrar un mecanismo que permita componer dichos fragmentos de acuerdo a una selección de  características dada, de esta forma, como se puede apreciar en la Figura~\ref{back:code:constSlicerPattern} líneas 16-20, el constructor para la clase Gateway es creado con las características seleccionadas por el usuario final, en el caso analizado, por ejemplo, solo se ha seleccionado la característica \imp{WindowMng}.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
File BaseSystem/Gateway.cs
--------------------------------------------------------
01 public partial class Gateway {
02      ...
03      private void BaseSystem_initGateway() {
04          this.floors = new List<Floors>();
05          this.interfaces = new List<CentralGUI>();
06      }
07 }

File WindowMng/Gateway.cs
--------------------------------------------------------
08 public partial class Gateway {
09      ...
10      private windowMng_initGateway() {
11          this.windows = new List<Window>();
12      }
13 }

File MyHouse/Gateway.cs
--------------------------------------------------------
14 public partial class Gateway {
15      ...
16      public Gateway() {
17          // WindowMng has been selected
18          baseSystem_initGateway();
19          windowMng_initGateway();
20      }
21 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Código para el constructor de la clase Gateway usando clases parciales y patrón slicer}
\label{back:code:constSlicerPattern}
\end{figure}

Concluyendo con el Patrón Slicer, tanto los métodos regulares como con los constructores pueden ser extendidos y reescritos usando dicho patrón y solucionando así las limitaciones ofrecidas por el uso de clases parciales~\cite{sanchez:2010} como mecanismo de soporte orientado a características. Utilizando todo lo expuesto en las secciones anteriores, en la siguiente sección se expone a grandes rasgos el funcionamiento de los generadores de código que serán empleados durante la fase de Ingeniería del Dominio del presente proyecto.

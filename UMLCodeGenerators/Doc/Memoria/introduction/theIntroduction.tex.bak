%%==================================================================%%
%% Author : Abascal Fernández, Patricia                             %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.0, 14/02/2013                                         %%                                                                                    %%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Archivo raíz                                                     %%
%%==================================================================%%

El principal objetivo de este Proyecto de Fin de Carrera es implementar un conjunto de generadores de código que permitan transformar modelos orientados a características para una línea de productos software en una implementación de dichos diseños para la plataforma .NET utilizando para ello las facilidades que ofrecen las clases parciales del lenguaje C\# basadas en el patrón Slicer. Dichos generadores de código abordarán tanto la implementación de la familia de productos software cubierta por la línea de productos, como la configuración de productos concretos pertenecientes a de dicha familia. A continuación intentaremos introducir de forma breve al lector en estos conceptos.

%%%%%%%%%%%% Lineas de productos software %%%%%%%%%%%%

El objetivo de la \emph{Línea de Producto Software}~\cite{polh:2010}, de un segmento particular de mercado, es reutilizar una base común de tecnología y proporcionar productos personalizados, acordes a las necesidades del cliente de manera eficiente, eficaz y a un coste razonable.

El uso de las líneas de producto software permite la reducción de costes de desarrollo por la reutilización de la tecnología en los distintos sistemas, a mayor cantidad de productos a desarrollar, mayor rentabilidad que los sistemas creados individualmente. Ofrece alta calidad en el producto resultante ya que se realizan pruebas de los artefactos de la plataforma en diferentes tipos de producto para ayudar a detectar y corregir errores. Reduce el tiempo de creación, ya que se reutilizan los artefactos ya existentes para cada nuevo producto y reduce también el esfuerzo requerido por el mantenimiento ya que cuando se cambia algo de un artefacto de la plataforma, ese cambio se propaga a todos los artefactos que lo empleen, y de esta forma se reduce el esfuerzo de aprender cómo funciona cada elemento individualmente.

En contraposición a la flexibilidad que ofrece el desarrollo de software invidivial, específico para cliente pero que supone grandes costes, las líneas de producto software delimitan las variaciones de sus productos a un conjunto prefijado y optimizan, por tanto, los procesos para dichas variaciones.

La línea de productos software se puede extrapolar a otros ámbitos de producción. Un ejemplo clásico de línea de productos es la fabricación de automóviles, donde se ofrece al cliente un modelo base al cual puede añadir aquellos extras que así desee, personalizando el vehículo y adaptándolo a sus necesidades. De esta forma, partiendo del mismo modelo y de unas variaciones adicionales preestablecidas y diseñadas de tal forma que se adaptan perfectamente al modelo seleccionado, se puede obtener gran cantidad de variaciones en el modelo final sin apenas esfuerzo adicional.

En el ámbito del desarrollo software, las empresas ya no se centran en la creación de un producto específico para un cliente (por ejemplo, diseñar y construir un portal para la Universidad de Cantabria), sino en un domino (por ejemplo, diseñar y construir un portal para universidades). Los principales desafíos a los que se enfrentan son: delimitar dicho dominio, identificar las distintas variaciones que se van a permitir y desarrollar la infraestructura que permita realizar los productos a bajo coste sin perder la calidad.


%%%%%%%%%%%% Metodologías de desarrollo de líneas de productos software %%%%%%%%%%%%

El proceso de desarrollo de la línea de productos software se divide en dos procesos: Ingeniería de Dominio e Ingeniería de la Aplicación. Por un lado la \emph{Ingeniería del Dominio} se encarga de la construcción de la plataforma mediante la delimitación del conjunto de aplicaciones para las que está creada además de definir y construir qué características serán reusables y cuales específicas para cada uno de los productos que se desean fabricar.

Por otra parte, la \emph{Ingeniería de la Aplicación} se encarga de la creación de los productos para clientes concretos. Partiendo de la plataforma creada en la fase de Ingeniería de Dominio, y reutilizando tantos componentes como fuera necesario, se crea una especialización del producto base acorde a los requisitos del cliente.

%%%%%%%%%%%% Programación orientada a características %%%%%%%%%%%%


Para desarrollar una línea productos software, se debe identificar el dominio y diferenciar qué características serán comunes y cuales específicas para cada uno de los productos que deseamos fabricar. Para realizar dicho análisis de la especificación se pueden utilizar distintas técnicas entre las cuales la más utilizada es la creación de árboles de características.

Un árbol de características es un tipo de modelo que especifica, tal como su nombre indica en forma de árbol, las características que puede poseer un producto concrete perteneciente a una familia de productos, indicando qué características son comunes a todos los productos, cuáles son variables, así como las razones por las cuales son variables.

Por ejemplo, en una línea de productos de agendas personales para teléfonos móviles, toda agenda personal debe permitir anotar eventos a los que debemos asistir en un futuro cercano. Por tanto, esta característica sería una característica obligatoria para todas las agendas personales. Sin embargo, ciertas agendas, dependiendo del precio que el usuario final esté dispuesto a pagar y las características técnicas de cada terminal, podrían ofrecer la función de geolocalizar el lugar del evento al que debemos asistir, y calcular la ruta óptima desde el lugar que le indiquemos a dicho lugar de destino. Esta última característica sería opcional, y podría no estar incluida en ciertas agendas personales instalados en terminales concretos.

Para obtener un producto específico dentro de una línea de productos software, el cliente debe especificar qué características concretas desea que posea el producto que va a adquirir. Es decir, en términos técnicos, debe crear una \emph{configuración} del árbol características. Obviamente, no toda selección de características da lugar a una configuración válida. Por ejemplo, toda configuración debe contener al menos el conjunto de características que son obligatorias para todos los productos. De igual forma, puede ser obligatorio escoger al menos una características de entre una serie de alternativas. Por ejemplo, la agenda personal podría estar disponible en castellano, inglés y francés. En este caso sería posible seleccionar cualquiera de las tres alternativas, pero al menos una debería incluirse en nuestro producto. También sería posible indicar que podemos seleccionar un único idioma, es decir, que no podemos instalar una agenda personal que soporte de forma simultánea dos idiomas distintos.

La mayoría de estas restricciones se pueden especificar usando la sintaxis propia de los árboles de características. No obstante, existen una serie de restricciones que no se pueden modelar con la sintaxis propia de los árboles de características. Un ejemplo de tal tipo de restricción son las relaciones de dependencias entre características. Por ejemplo, la selección de una característica de cálculo de rutas óptimas podría necesitar para funcionar que  estuviesen instalados los servicios de mapas y geolocalización. Dichas tres características podrían no aparecer relacionadas en el árbol de características, por lo que tendríamos que definir dicha restricción como una restricción externa.





---------------------

Tal como se ha descrito al inicio de este apartado, el objetivo del presente proyecto consiste en el desarrollo e implementación de unos generadores de código que permitan la tranformación del diseño de los modelos en una implementación en código C\# de dichos diseños.

------------------------------

%%%%%%%%%%%%%%%%%%%%%

Para solventar dicho problema, el profesor Pablo Sánchez, dentro del Departamento de Matemáticas, Estadística y Computación, ha desarrollado un nuevo lenguaje para la especificación y validación de restricciones externas a los árboles de características donde dichas restricciones pueden contener \emph{características clonables}. Dicho lenguaje se denomina \emph{HCL (Hydra Constraint Language}).

El objetivo de este Proyecto Fin de Carrera es implementar un editor que permita especificar y validar restricciones especificadas en HCL, es decir restricciones sobre árboles de características que puedan incluir características clonables. Dicho editor se debe integrar en una herramienta para el modelado y configuración de árboles de características denominada \emph{Hydra}, desarrollada también por el profesor Pablo Sánchez, en colaboración con un antiguo alumno suyo de la Universidad de Málaga, José Ramón Salazar. Con esto esperamos haber aclarado el primer párrafo de esta sección al lector no familiarizado con las líneas de productos software y/o los árboles de características.

Hydra se distribuye actualmente como un plugin para Eclipse, y ha sido desarrollada utilizando modernas técnicas de \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{}. Dichas técnicas permiten una rápida y cómoda creación de entornos de edición y evaluación de lenguajes tanto visuales como textuales mediante la especificación de una serie de elementos básicos a partir de los cuales se genera una gran cantidad de artefactos, reduciendo los tiempos de desarrollo y costo asociado al desarrollo de dichos entornos. El editor desarrollado en este Proyecto Fin de Carrera deberá distribuirse también como un plugin para Eclipse, instalable sobre \emph{Hydra}. Para su desarrollo se usará también un enfoque de \emph{Ingeniería de Lenguajes Dirigida por Modelos}~\cite{}.

Tras esta introducción, el resto del presente capítulo se estructura como sigue: La Sección~\ref{sec:intr:sle} proporciona unas nociones básicas sobre la \emph{Ingeniería de Lenguajes Dirigida por Modelos}, nociones que son necesarias para poder entender la planificación del presente proyecto, la cual se describe en la Sección~\ref{sec:intr:planning}. Por último, la Sección~\ref{sec:intr:estructura} describe la estructura general del presente documento.

%==================================================================%
% Author : Pérez Ruiz, Alejandro                                   %
% Version: 1.0, 16/03/2011                                         %                                                                                    %                                                                  %
% Memoria del Proyecto Fin de Carrera                              %
% Capítulo Application Engineering, Archivo raíz                   %
%==================================================================%

\chapterheader{Application Engineering}{Application Engineering}

\label{chap:application}

% Introducción al capítulo
La ingeniería de aplicación es un proceso en el cual, las aplicaciones de una línea de productos se construyen a través de los artefactos creados en la fase de ingeniería de dominio y la explotación de la variabilidad de las líneas de producto software \cite{pohl:2005}.
Los principales objetivos de la ingeniería de aplicación son: alcanzar un nivel tan alto como sea posible de reutilizar los elementos del dominio cuando se definan y desarrollen aplicaciones de la línea de productos y  explotar la variabilidad y los elementos comunes de la línea de productos software durante el desarrollo de aplicaciones. Por lo que este capítulo presentará al lector el proceso seguido para conseguir reutilizar y componer los elementos creados en la fase de ingeniería de dominio. De tal modo que se deriven tan automáticamente como sea posible aplicaciones adaptadas a los diferentes requisitos de cada usuario. Además se mostrarán cuales han sido los problemas y las soluciones adoptadas a la hora de trabajar con el lenguaje C\#, sus clases parciales, y la plataforma .NET.
\chaptertoc
\section{Proceso de composición de características}
%% Section{Proceso de composición de las features}
%% (explicar como se ha conseguido **Hacerlo bien**)
En el capítulo \ref{chap:domain} anterior describimos el proceso para crear la infraestructura necesaria de la que se puedan derivar configuraciones concretas durante la fase de ingeniería de aplicación (ver Capítulo
\ref{chap:background}). El objetivo de esta fase de ingeniería de aplicación es componer características de la forma más cómoda y automática posible.

La infraestructura creada en el capítulo interior se crea con el objetivo de que sea usada para derivar de ella un número largo de aplicaciones concretas, las cuales compartirán dicha infraestructura común. Por tanto,
deberíamos intentar evitar tener que replicar esta infraestructura con objeto de evitar redundancias y los típicos problemas asociados al código replicado. Por ejemplo, si replicásemos el código por cada
producto concreto creado, cualquier modificación que se realizase sobre la infraestructura, habría que propagarla a todos estos productos. Este puede ser un serio problema a medida que el número de productos
derivados crece.

Por tanto, la solución natural es encapsular el código creado durante la fase de ingeniería de dominio en una biblioteca o componente modificable que el usuario no pueda reutilizar. Esto no obstante, va a a
generar una serie de problemas adicionales a la hora de componer características y que comentamos a continuación.

Antes de comentar dichos problemas, recordar que uno de los requisitos principales de este proyecto es que tenía que funcionar en el lenguaje C\# de la plataforma .NET, y más concretamente, dentro del entorno Visual
Studio\cite{randolph:2010}. Esto va a a introducir una complejidad adicional en el proceso de composición de características que comentamos a continuación, con ayuda de un ejemplo concreto.

Cuando se intenta crear una composición de características para un hogar inteligente en el que deseamos que aparezca el control inteligente de energía, obligatoriamente, debemos seleccionar el control de los calefactores y de las ventanas (ver Sección \ref{}). Además el método que se encargaba de ajustar la temperatura de un calefactor tenía una doble implementación, por un lado la característica control de calefactores tenía una implementación del método básica, donde simplemente se establecía la temperatura deseada, mientras que en la característica control de energía inteligente se establecía la temperatura y se cerraban las ventanas para que no existiesen pérdidas.

Esto obliga a solventar dos problemas, por un lado impedir que el usuario haga configuraciones incorrectas (esto será resuelto en el siguiente Capítulo\ref{}) y conseguir extender la funcionalidad de las clases parciales desde el componente que representé a la fase actual. Por lo tanto la primera pregunta que debemos resolver es ¿Cómo encapsular y relacionar el código de la fase de Ingeniería del Dominio con el desarrollado en la fase de Ingeniería de Producto? La plataforma .NET y el entorno Visual Studio proporcionan la capacidad de crear soluciones en la que pueden aparecer varios proyectos, por lo que se crearán dos proyectos en una misma solución. El primer proyecto contendrá el código creado en la fase de ingeniería de dominio, mientras que el segundo proyecto contendrá todos los artefactos necesarios para la fase de ingeniería de aplicación. Este último proyecto tendrá acceso al código del otro proyecto a través de la definición de una referencia, que permite que un proyecto tenga la posibilidad de usar un espacio de nombres perteneciente a otro proyecto. La siguiente cuestión es ¿Cómo extender la funcionalidad de determinadas clases parciales cuando se realiza una configuración concreta? Como primera respuesta a esta pregunta se trató de definir la clase parcial que se quería extender en el proyecto destinado a la Ingeniería del Producto, pero esto no es posible, ya que, el compilador no considera que ambas clases parciales son la misma, sino que trata de compilarlas por separado, por lo que esto provoca un conflicto de ambigüedad.

Por lo que se nos presenta el primer problema que no puede ser resuelto de una forma inmediata, de este modo se ha ideado un procedimiento que permita solucionarlo, el cual es descrito a continuación:

\begin{enumerate}
\item Por cada clase que existía en el proyecto de la fase de ingeniería de dominio se crea una nueva clase en el proyecto correspondiente a la ingeniería de aplicación que herede de la clase necesaria, por ejemplo, en la figura \ref{application:fig:room} se muestra el código para la clase \imp{MyHome\_Room}, que hereda de la clase \imp{Room} desarrollada en la fase de ingeniería de dominio.

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 using SmartHome;
01 namespace MyHome
02 {
03  class MyHome_Room: Room
04    {
05        public MyHome_Room(String name, int id)
06            : base(name, id) { }
07    }
08 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Código para la clase \imp{MyHome\_Room} en la ingeniería de aplicación.}
\label{application:fig:room}
\end{figure}


\item Los métodos que su implementación dependa de la característica seleccionada (ver el Capítulo \ref{chap:domain}), son definidos como \emph{virtual}, para que puedan ser sobrescritos e implementados cuando sean heredados en el proyecto que es implementado para la ingeniería de aplicación. A modo de ejemplo se ilustra la figura \ref{application:fig:virtualMethods} que contiene la implementación del método \imp{heaterAdjustTemperature} en la infraestructura creada en la fase de ingeniería de dominio.

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00  public virtual void heaterAdjustTemperature(int id, double temperature)
01  {
02     //Su implementación es definida en la fase de ingeniería de aplicación.
03  }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del método virtual \imp{heaterAdjustTemperature} en la infraestructura de la fase de ingeniería de dominio.}
\label{application:fig:virtualMethods}
\end{figure}



\item En el proyecto de la fase de ingeniería de aplicación se sobrescriben los métodos heredados necesarios del punto anterior, por ejemplo en la figura \ref{application:fig:gateway} se ilustra el código de la clase parcial \imp{Gateway} cuando se ha seleccionado la característica control inteligente de energía (SmartEnergyMng), por lo que el método \imp{heaterAdjustTemperature} deberá utilizar la implementación del método que se encuentra en la característica SmartEnergyMng.

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 using SmartHome;
01 namespace MyHome
02 {
03    partial class MyHome_Gateway:Gateway
04    {
05        public MyHome_Gateway()
06            : base() { }
07        public override void heaterAdjustTemperature(int id, double temperature)
08        {
09            this.smartEnergy_HeaterAdjustTemperature(id, temperature);
10        }
11    }
12 }
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación de la clase \imp{MyHome\_Gateway} cuando es seleccionada la característica control de energía inteligente.}
\label{application:fig:gateway}
\end{figure}

\item Crear un método \imp{Main} que instancie y utilice las clases desarrolladas durante los pasos previos.
\end{enumerate}

Con esto procedimiento se consiguen componer características sin modificar el código de la ingeniería de dominio, con lo que se evitan los problemas de replicación de código mencionados anteriormente. Pero con esto no se consigue automatizar el proceso para derivar productos concretos, únicamente se obtiene un mecanismo que necesita aplicarse manualmente, ya que por un lado es necesario heredar de las clases que correspondan según la características seleccionadas. Por ejemplo, si la característica HeaterMng no se selecciona, las clases \imp{HeaterCtrl} y \imp{Thermometer} no deben ser heredadas e implementadas en la fase de ingeniería de aplicación. Y por otro lado se necesita implementar algunos métodos en función de las características elegidas, tal y como se comentó en el proceso descrito con anterioridad.

Por lo tanto, las siguientes secciones describen las partes del puzzle que son requeridas para completar la automatización en la composición de características. Concretamente la siguiente sección ilustra como se ha definido un metamodelo para que a partir de él se puedan crear modelos que no incumplan ninguna de las restricciones.
\section{Metamodelo y modelos}
Tras haber desarrollado un procedimiento para componer características en la sección anterior, ahora se necesita obtener un metamodelo. Un metamodelo es un modelo que define el lenguaje para expresar un modelo \cite{kleppe:2008}. Los metamodelos son complementados por procesos y/o restricciones que validan que los modelos no sean violados cuando se creen, modifiquen o eliminen datos.

Con la ayuda de un metamodelo que defina modelos de una la línea de productos software para hogares inteligentes, se podrá automatizar el proceso de composición de características. De este modo, por una parte se consigue evitar que el usuario realice configuraciones incorrectas, ya que los metamodelos contienen restricciones para evitar modelos inválidos. Y por otro lado, se consigue que la composición sea más cómoda y abstracta, debido a que los usuarios no deben conocer todos los detalles de la implementación que subyace.

El entorno de desarrollo Visual Studio contiene una serie de herramientas, denominadas \emph{Domain-Specific Language Tools (DSL Tools)} \cite{jones:2011}, que permiten crear herramientas basadas en el desarrollo por modelos que posteriormente podrán ser integradas en el propio entorno de Visual Studio.
La principal característica de DSL Tools es la definición de metamodelos para representar un concepto, como por ejemplo un hogar inteligente. Este metamodelo puede rodearse de una gran variedad de herramientas, tales como vista en diagramas, la posibilidad de generar código u otros artefactos, comandos para transformaciones y la posibilidad de interactuar con código y otros objetos en Visual Studio.

\begin{figure}[!tb]
 \centering
 \includegraphics[width=.65\linewidth]{applicationEngineering/images/metaModel.eps} \\
 \caption{Metamodelo para un hogar inteligente}
 \label{app:fig:metamodel}
\end{figure}


Por lo tanto, el propio Visual Studio integra las herramientas para automatizar todo el proceso de composición de características. De este modo, en primera instancia se diseña el metamodelo (ver figura \ref{app:fig:metamodel}) que nos permita definir modelos para un hogar inteligente. Posteriormente el metamodelo es trasladado a Visual Studio y se le asigna una notación específica. Pero el metamodelo no es completo porque algunas restricciones no están añadidas. Las restricciones que implícitamente aparecen en el metamodelo son las relacionadas con la cardinalidad, por ejemplo, siempre es necesario añadir una planta al hogar inteligente. Pero algunas como la C1, C2 y C3, que aparecen en la figura \ref{app:fig:metamodel} deben ser definidas explícitamente mediante código para que sean validadas.

De esta manera se consigue integrar en el propio entorno una nueva herramienta que permite construir modelos específicos y que evita que los usuarios creen configuraciones incorrectos. Por lo que también se puede decir que se ha abstraído el proceso para la composición de características, aunque con una herramienta que nos permita crear modelos no se completa el puzzle, ya que los modelos deben ser utilizados para que a partir de ellos se obtenga el código para la composición de las características. Por ello, la siguiente sección describirá como las plantillas de generación de código son utilizadas para este cometido.


\section{Plantillas de generación de código}
%% Section{Metamodelo y Modelo}
Las plantillas de generación de código \emph{T4 Text Templates} \cite{vogel:2010} son una forma rápida y sencilla de construir código a través de bloques de texto y código escrito en lenguaje C\# o VB. Este tipo de plantillas se introdujeron con Visual Studio 2005, y son una solución muy adecuada para el presente proyecto porque se encuentran integradas en el propio entorno de Visual Studio, por lo que otras alternativas como MOFScript \cite{oldevik:2005}, que es un lenguaje de transformación de modelo a texto basado en estándares de la OMG y desarrollado como un plugin para Eclipse, se desestimaron.

La sintaxis para crear plantillas es sencilla, en la figura \ref{application:fig:t4template} se ilustra un pequeño ejemplo en el que aparece como se deben usar. Por un lado, en la línea 00 se describe una directiva de ensamblado que indica que los bloques de código para esta plantilla serán escritos en C\#, y por otro lado en la siguiente línea se ilustra como los bloques de código que se quieren ejecutar deben de encontrarse delimitados por los siguientes caracteres: <\# \#>. Además existe la posibilidad de que se quiera mostrar el valor de una variable que se ejecuta en un bloque de código, por lo que sería necesario envolver la variable entre los caracteres <\#= \#>, tal y como se muestra en la línea 2 de la figura.

\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 <#@ template language="C#" #>
01 Hello <# Write("World!"); #>
02 Today is <#= DateTime.Now.ToString() #>
\end{verbatim}
\end{footnotesize}
\caption{Ejemplo de uso de las plantillas T4}
\label{application:fig:t4template}
\end{center}
\end{figure}


Por lo tanto, se tiene un metamodelo que nos permite crear modelos que no violen las restricciones, por lo que a través de las plantillas de generación de código, se obtendrá el código correspondiente con el modelo creado por el usuario, para componer las características. Para ello es necesario hacer uso de la clase \imp{ModelingTextTransformation}, la cual permite acceder a las clases, propiedades y relaciones disponibles en un modelo.

Teniendo el acceso a las propiedades del modelo, se genera la clase que contiene el método \imp{Main} que instancia todos los componentes del hogar inteligente, además de las clases que definen los dispositivos y aquellas que tenían métodos virtuales cuya implementación dependía de las características que fuesen seleccionadas (ver Sección \todo{PONER SECCIÓN}). Por ejemplo, si se crea un modelo en el que solo existe el control de los calefactores, las clases para los dispositivos como \imp{WindowCtrl}, \imp{WindowSensor}, \imp{LightCtrl}... no son necesarias, por lo que las plantillas de generación de código no las crearán.

Cabe recordar que en el entorno de desarrollo existen dos proyectos, uno que contiene la infraestructura desarrollada durante la fase de ingeniería de dominio y otro que contiene todos los artefactos creados durante la fase actual. Por lo que en el proyecto desarrollado durante la fase de ingeniería de dominio se encuentran todas las características encapsuladas mediante las clases parciales. Y como ya se comentó (ver Sección \todo{PONER SECCIÓN}) los proyectos poseen un fichero escrito en XML donde se almacenan los elementos que serán compilados. Por lo que cuando se deriven productos es necesario indicar que elementos serán compilados, para evitar que características que no estén seleccionadas para la configuración actual se compilen, de tal modo que se gane en eficiencia y seguridad. En primera instancia, se contempló y probó la posibilidad de sobreescribir el fichero XML mediante las plantillas T4, pero el resultado no fue el esperado, debido a que el fichero XML es usado por la solución donde se encuentran los dos proyectos, es necesario reabrir la solución actual para que el fichero XML de compilación se cargue adecuadamente. Así que por ello, desde las propias plantillas T4 se debe indicar que elementos incluir o excluir de el proyecto para la compilación. Para tal cometido existe una
una librería denominada \imp{EnvDTE}, la cual contiene métodos para instanciar/automátizar el propio entorno de desarrollo de Visual Studio. Por lo que a través de un bloque de código de las plantillas T4 se utiliza la libería \imp{EnvDTE} para indicar que elementos deben estar excluidos o incluidos dentro del proyecto de la fase de ingeniería de dominio, para que de este modo solo se compilen las características seleccionadas.

De algún modo es necesario que los elementos creados hasta este momento sean encapsulados como plugins para el entorno Visual Studio, y puedan ser utilizados en cualquier computadora que tenga instalada una versión del entorno de desarrollo. Por lo que la siguiente sección describe el proceso seguido para crear los instaladores y su despliegue.
%%% Muy breve
\section{Instaladores y despliegue}
%% Section{Instaladores y Despliegue}

Es necesario que todos los artefactos creados hasta este punto sean empaquetados en plugins para que puedan extender la funcionalidad del entorno de desarrollo Visual Studio, sean distribuidos y se puedan instalar en cualquier ordenador. Para tal cometido, en primer lugar se crea un instalador que permita crear modelos de un hogar inteligente, el cuál ha sido desarrollado en la Sección \todo{PONER SECCIÓN}. De tal modo que se construye un archivo con extensión \emph{MSI (Windows Installer)}, que permite ser instalado en cualquier ordenador que posea la versión Professional 2010 del entorno Visual Studio. Lo que hace este instalador es añadir un nuevo elemento a Visual Studio, para poder crear en cualquier proyecto, un archivo que permita definir modelos de un hogar inteligente a través del metamodelo definido en la Sección \todo{PONER SECCIÓN}.

El segundo instalador permitirá a los usuarios añadir un nuevo plugin en Visual Studio que agregue una nueva solución a Visual Studio, la cual contendrá los dos proyectos creados en la fase de ingeniería de aplicación y de dominio. De tal modo, que instalando este plugin cualquier usuario podrá definir en su computadora su propia aplicación para un hogar inteligente. Debido a ciertos detalles técnicos de bajo nivel, que se omiten en aras de la brevedad y evitar aburrir al lector, el desarrollo de este instalador llevó un tiempo bastante mayor del inicialmente planeado. Su desarrollo supuso un esfuerzo extra, contrastando con el otro instalador, que requirió menor cantidad de tiempo. El principal problema se derivaba de la incapacidad de que ambos proyectos mantuviesen correctamente las referencias entre ellos cuando eran integrados como un nuevo plugin.

Ambos instaladores estarán disponibles a través de una página web, realizada con el único objetivo de dar a conocer el presente proyecto. Dicha web tendrá 5 secciones, que son descritas a continuación:
\begin{enumerate}
\item \emph{Introducción: }Contendrá un breve resumen para mostrar y presentar cual es el ámbito y los objetivos del proyecto.
\item \emph{Descargas: }En esta sección estarán disponibles los instaladores creados.
\item \emph{Documentación: }Mostrará toda la documentación relacionada con el proyecto.
\item \emph{Publicaciones: }Contendrá todas las publicaciones referentes al proyecto.
\item \emph{Contacto: }Sección para poder contactar con los creadores del proyecto.
\end{enumerate}


\section{Sumario}
Este capítulo ha mostrado los distintos pasos necesarios para realizar la composición de características en la plataforma .NET a través del lenguaje C\# y sus clases parciales. El primero de los pasos ha consistido en encontrar una modo de encapsular de forma separada el código creado en las fases de ingeniería de aplicación y dominio, para permitir derivar un número largo de aplicaciones concretas. Para tal cometido ha sido necesario desarrollar un mecanismo que supliese las carencias que existen en la plataforma .NET. En segunda instancia se ha desarrollado un metamodelo que permita crear modelos de un hogar inteligente, para que los usuarios pueden realizar configuraciones abstrayéndose de la implementación que subyace y evitar que se creen configuraciones que no sean válidas. A continuación, para completar la automatización, se presentan las plantillas de generación de código, que a través de los modelos que cree el usuario, obtendrán el código necesario para componer las características. Por último, se expone el proceso seguido para construir los instaladores que permiten distribuir todo el software creado hasta este momento y una página web usada como mecanismo de despliegue. 
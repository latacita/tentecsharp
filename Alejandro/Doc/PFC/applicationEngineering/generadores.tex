%%=================================================================%%
%% Author : Pérez Ruiz, Alejandro                                  %%
%% Author : Sánchez Barreiro. Pablo                                %%
%%                                                                 %%
%% Version: 1.0, 16/03/2011                                        %%                                                                                    %% Version: 1.1, 20/06/2011                                        %%                                                                                    %%                                                                 %%
%%                                                                 %%
%% Memoria del Proyecto Fin de Carrera                             %%
%% ApplicationEngineering/Generadores de Código                    %%
%%=================================================================%%

Las plantillas de generación de código son una forma rápida y sencilla de construir código a través de plantillas que especifican porciones estáticas de código con porciones que se generan dinámicamente a partir de ciertos parámetros de entrada, al estilo de las páginas web dinámicas. El lenguaje de generación de código del entorno Visual Studio de denomina \emph{T4 Text Templates}~\cite{vogel:2010}. Se ha usado este lenguaje de generación de código frente a otras opciones, tales como MOFScript~\cite{oldevik:2005}, por ser el lenguaje que mejor se integra dentro de nuestro entorno de dearrollo.

La Figura~\ref{application:fig:t4template} ilustra un pequeño ejemplo de como se usan estas plantillas. Los trozos de código escritos entre los caracteres $<$\# y \#$>$ son trozo de código escritos en el lenguaje T4, en este caso usando el lenguaje C\#. Los caracteres $<$\#= \#$>$ se usan para indicar que el valor producido por la ejecución de un determinada porción de código debe escribirse en el fichero de salida. El texto situado fuera de estos caracteres se incorpora tal cual aparece en los ficheros de salida.

En el caso de la Figura~\ref{application:fig:t4template}, la línea 00 especifica que el código contenido entre los caracteres de escape ($<$\# \#$>$ y $<$\#= \#$>$) están escritos en C\#. La línea 01 escribe \imp{Hello} en el fichero de salida. Además, se ejecuta el trozo de código contenido en los caracteres de escape, que en este caso escribiría  \imp{World} en la salida por defecto. La línea 02 escribiría en el fichero de salida \imp{Today is}, y a continuación el valor resultante de ejecutar el trozo de código contenido entre los caracteres de escape. Es decir, la fecha actual.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 <#@ template language="C#" #>
01 Hello <# Write("World!"); #>
02 Today is <#= DateTime.Now.ToString() #>
\end{verbatim}
\end{footnotesize}
\caption{Ejemplo de uso de las plantillas T4}
\label{application:fig:t4template}
\end{center}
\end{figure}

Usando estas plantillas, y aceptando un modelo conforme al metamodelo creado en la sección anterior como entrada, generaremos el código necesario para componer e instanciar las diferentes características de nuestra línea de productos. Para ello es necesario hacer uso de la clase \imp{ModelingTextTransformation}, la cual permite acceder a las clases, propiedades y relaciones disponibles en un modelo.

Utilizando este tipo de plantillas y las funciones proporcionadas por la clase \imp{ModelingTextTransformation} se ha seguido un proceso para llevar a cabo la generación de código que es descrito a continuación:

%%=================================================================%%
%% NOTA(Pablo): Poner esto mejor descrito, punto por punto y en    %%
%%              orden de ejecución                                 %%
%%=================================================================%%

%%=================================================================%%
%% HECHO(Pablo): Poner un trozo de código con una plantilla real    %%
%%=================================================================%%

\begin{enumerate}
	\item Por cada característica seleccionada es necesario llevar a cabo el proceso descrito en la Sección~\ref{sec:application:composition}. Por tanto, por cada característica y cada clase concreta dentro de esa característica, existe una plantilla T4 que se encarga de generar su código correspondiente, de tal modo que para las clases correspondientes a características no seleccionadas no generaremos código alguno. A modo de ejemplo, la Figura~\ref{application:fig:t4templateHeater} muestra parte de la plantilla destinada a la característica para la gestión automática de la temperatura. En primer lugar en la línea 01 se comprueba que la característica haya sido seleccionada. Si es así, se generan las clases concretas correspondientes, \imp{MyHome\_HeaterCtrl} en nuestro caso (Figura~\ref{application:fig:t4templateHeater}, línea 06). Si dicha características no ha sido seleccionada, no se genera nada.
	\item Generamos además una clase \imp{Launcher} con un método \imp{main} que sirve para crear los objetos iniciales que formarán parte de un producto concreto así como para componerlos de manera adecuada. Por ejemplo, se instanciarán tantas plantas como indique el modelo de entrada, y cada objeto de tipo \imp{Floor} se añadirá a la correspondiente lista del \imp{Gateway}.
\end{enumerate}

\begin{figure}[h!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 <#...
01 if(heaterMng) {
02 #>
03 using SmartHome;
04 namespace MyHome
05 {
06    class MyHome_HeaterCtrl : HeaterCtrl
07    {
08        public MyHome_HeaterCtrl(int id, int id_room)
09            : base(id, id_room) { }
10    } // MyHome_HeaterCtrl
11 } // MyHome
12 <#
13 } // if
18 #>
\end{verbatim}
\end{footnotesize}
\caption{Plantilla T4 para la característica control automático de los calefactores.}
\label{application:fig:t4templateHeater}
\end{center}
\end{figure}


Tras seguir el proceso anterior conseguimos obtener de manera automática todo el código necesario para poder ejecutar un producto concreto perteneciente a nuestra línea de productos.

No obstante cabe recordar que en el entorno de desarrollo existen dos conjuntos distintos de artefactos: (1) uno que contiene la infraestructura desarrollada durante la fase de ingeniería del dominio; y (2) otro que contiene todos los artefactos creados durante la fase de ingeniería de la aplicación. El primer conjunto de artefactos contiene la lógica necesaria para ejecutar cualquier característica, haya sido seleccionada o no. Por tanto, dicha lógica se añadirá a los ejecutables resultantes la fase de ingeniería de la aplicación. Por tanto, para productos con pocas características seleccionadas, el código correspondiente a las características no seleccionadas se añadirá al ejecutable final, incrementando innecesariamente su tamaño.

Para evitar esto, trataremos de evitar que el código correspondiente a características no seleccionadas sea compilado y añadido a los ejecutables correspondientes a un producto concreto. Tal como se comentó en la Sección~\ref{background:sec:partialClasses}, los proyectos en Visual Studio poseen un fichero XML que especifica que elementos del proyecto serán compilados y se añadirán a los ejecutables generados. Por tanto, la idea es manipular explícitamente ese fichero para excluir de la compilación el código correspondiente a características no seleccionadas.

Para manipular dicho fichero XML, Visual Studio proporciona una API denominada \imp{EnvDTE}, la cual contiene métodos para instanciar y/o automatizar el propio entorno de desarrollo de Visual Studio. Por lo que a través de las plantillas T4 podemos invocar dicha API para indicar qué elementos deben excluirse del proceso de compilación, con objeto de minimizar el tamaño de los ejecutables producidos.

Una vez creada la infraestructura para nuestra línea de productos software, el siguiente paso es empaquetarla para posibilitar su distribución y uso. La siguiente sección describe como se realiza dicha fase de despliegue. 
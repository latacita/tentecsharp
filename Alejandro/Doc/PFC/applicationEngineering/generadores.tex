%%=================================================================%%
%% Author : Pérez Ruiz, Alejandro                                  %%
%% Author : Sánchez Barreiro. Pablo                                %%
%%                                                                 %%
%% Version: 1.0, 16/03/2011                                        %%                                                                                    %% Version: 1.1, 20/06/2011                                        %%                                                                                    %%                                                                 %%
%%                                                                 %%
%% Memoria del Proyecto Fin de Carrera                             %%
%% ApplicationEngineering/Generadores de Código                    %%
%%=================================================================%%

Las plantillas de generación de código son una forma rápida y sencilla de construir código a través de plantillas que especifican porciones estáticas de código con porciones que se generan dinámicamente a partir de ciertos parámetros de entrada, al estilo de las páginas web dinámicas. El lenguaje de generación de código del entorno Visual Studio de denomina \emph{T4 Text Templates}~\cite{vogel:2010}. Se ha usado este lenguaje de generación de código frente a otras opciones, tales como MOFScript~\cite{oldevik:2005}, por ser el lenguaje que mejor se integra dentro de nuestro entorno de dearrollo.

La Figura~\ref{application:fig:t4template} ilustra un pequeño ejemplo de como se usan estas plantillas. Los trozos de código escritos entre los caracteres $<$\# y \#$>$ son trozo de código escritos en el lenguaje T4, en este caso usando el lenguaje C\#. Los caracteres $<$\#= \#$>$ se usan para indicar que el valor producido por la ejecución de un determinada porción de código debe escribirse en el fichero de salida. El texto situado fuera de estos caracteres se incorpora tal cual aparece en los ficheros de salida.

En el caso de la Figura~\ref{application:fig:t4template}, la línea 00 especifica que el código contenido entre los caracteres de escape ($<$\# \#$>$ y $<$\#= \#$>$) están escritos en C\#. La línea 01 escribe \imp{Hello} en el fichero de salida. Además, se ejecuta el trozo de código contenido en los caracteres de escape, que en este caso escribiría  \imp{World} en la salida por defecto. La línea 02 escribiría en el fichero de salida \imp{Today is}, y a continuación el valor resultante de ejecutar el trozo de código contenido entre los caracteres de escape. Es decir, la fecha actual.

\begin{figure}[tb!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 <#@ template language="C#" #>
01 Hello <# Write("World!"); #>
02 Today is <#= DateTime.Now.ToString() #>
\end{verbatim}
\end{footnotesize}
\caption{Ejemplo de uso de las plantillas T4}
\label{application:fig:t4template}
\end{center}
\end{figure}

Usando estas plantillas, y aceptando un modelo conforme al metamodelo creado en la sección anterior como entrada, generaremos el código necesario para componer e instanciar las diferentes características de nuestra línea de productos. Para ello es necesario hacer uso de la clase \imp{ModelingTextTransformation}, la cual permite acceder a las clases, propiedades y relaciones disponibles en un modelo.

Utilizando este tipo de plantillas y las funciones proporcionadas por la clase \imp{ModelingTextTransformation} se ha seguido un proceso para llevar a cabo la generación de código que es descrito a continuación:

%%=================================================================%%
%% NOTA(Pablo): Poner esto mejor descrito, punto por punto y en    %%
%%              orden de ejecución                                 %%
%%=================================================================%%

%%=================================================================%%
%% HECHO(Pablo): Poner un trozo de código con una plantilla real    %%
%%=================================================================%%


\begin{enumerate}
	\item Por cada característica seleccionada es necesario llevar a cabo el proceso descrito en la Sección \ref{sec:application:composition}. Por lo que, por cada característica existe una plantilla T4 que se encarga de generar su código correspondiente, de tal modo, que para las características no seleccionadas no generaremos código. A modo de ejemplo se ilustra en la figura \ref{application:fig:t4templateHeater} parte del código de la plantilla destinada a la característica control automático de los calefactores. En primer lugar en la línea 01 se comprueba que la característica haya sido seleccionada, en tal caso se genera su código correspondiente, mientras que si no ha sido seleccionada, se creará un archivo vacío.

\begin{figure}[h!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 ...
01 if(heaterMng) {
02 #>
03 using SmartHome;
04 namespace MyHome
05 {
06    partial class MyHome_HeaterCtrl : HeaterCtrl
07    {
08        public MyHome_HeaterCtrl(int id, int id_room)
09            : base(id, id_room) { }
10    }
11 }
12 <#
13 }else{
14 #>
15	//heaterMng no se ha seleccionado.
16 <#
17 }
18 #>
\end{verbatim}
\end{footnotesize}
\caption{Plantilla T4 para la característica control automático de los calefactores.}
\label{application:fig:t4templateHeater}
\end{center}
\end{figure}
	
	
	\item Debemos generar una clase \imp{Launcher} con un método \imp{main} que sirva para crear los objetos iniciales que formarán parte de un producto concreto y componerlos de manera adecuada, tal y como hemos visto en la Sección \ref{sec:application:composition}. De este modo, según las características seleccionadas la plantillas generarán código para instanciar los objetos correspondientes.
\end{enumerate}

Tras seguir el proceso anterior conseguimos obtener de una manera automática todo el código necesario para poder ejecutar una configuración concreta de un hogar inteligente, no obstante cabe recordar que en el entorno de desarrollo existen dos proyectos, uno que contiene la infraestructura desarrollada durante la fase de ingeniería de dominio y otro que contiene todos los artefactos creados durante la fase actual. Por lo que en el proyecto desarrollado durante la fase de ingeniería de dominio se encuentran todas las características encapsuladas mediante las clases parciales. Y como ya se comentó (ver Sección \ref{background:sec:partialClasses}) los proyectos poseen un fichero escrito en XML donde se almacenan los elementos que serán compilados. Por lo que cuando se deriven productos es necesario indicar que elementos serán compilados, para evitar que características que no estén seleccionadas para la configuración actual se compilen, de tal modo que se gane en eficiencia y seguridad. En primera instancia, se contempló y probó la posibilidad de sobreescribir el fichero XML mediante las plantillas T4, pero el resultado no fue el esperado, debido a que el fichero XML es usado por la solución donde se encuentran los dos proyectos, es necesario reabrir la solución actual para que el fichero XML de compilación se cargue adecuadamente. Así que por ello, desde las propias plantillas T4 se debe indicar que elementos incluir o excluir de el proyecto para la compilación. Para tal cometido existe una librería denominada \imp{EnvDTE}, la cual contiene métodos para instanciar y/o automatizar el propio entorno de desarrollo de Visual Studio. Por lo que a través de un bloque de código de las plantillas T4 se utiliza la libería \imp{EnvDTE} para indicar que elementos deben estar excluidos o incluidos dentro del proyecto de la fase de ingeniería de dominio, para que de este modo solo se compilen las características seleccionadas.

De algún modo es necesario que los elementos creados hasta este momento sean encapsulados como plugins para el entorno Visual Studio, y puedan ser utilizados en cualquier computadora que tenga instalada una versión del entorno de desarrollo. Por lo que la siguiente sección describe el proceso seguido para crear los instaladores y su despliegue.

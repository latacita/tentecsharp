%=========================================================================%
% Author : Alejandro Pérez Ruiz                                           %
% Author : Pablo Sánchez Barreiro                                         %
% Version: 1.1, 10/06/2011                                                %
% Master Thesis: Background/Feature Oriented Programming                  %
%=========================================================================%

La programación orientada a características~\cite{prehofer:2001} surge como respuesta a las limitaciones que el diseño y la programación orientada a objetos posee en relación a la implementación de las línea de productos software. Por tanto, antes de describir en qué consiste la programación orientada a características, comentaremos qué propiedades serían deseables encontrar en un lenguaje para la implementación de líneas de productos software y analizaremos cómo satisfacer las técnicas de desarrollo software orientado a objetos dichas propiedades, comentando sus principales limitaciones.

\subsection{Propiedades deseables de un lenguaje de programación para la implementación de líneas de productos software}
\label{back:subsec:propiedades}

\input{background/propiedadesFop.tex}

\subsection{Limitaciones de la orientación a objetos respecto a la implementación de líneas de productos software}
\label{back:sub:limitacionesOO}

\input{background/OOshortcomings.tex}

\subsection{Lenguajes de programación orientados a características}
\label{back:subsec:foLanguages}

Los lenguajes orientados a características~\cite{prehofer:2001} tienen como objetivo encapsular conjuntos coherentes de funcionalidad de un sistema software en módulos independientes y fácilmente componibles de forma que se incremente la capacidad de reutilización y extensión de estos módulos. Dichos módulos reciben el nombre de \emph{característica}. Una característica se suele definir como un incremento de la funcionalidad de un sistema~\cite{batory:2004}.

%%===============================================================================================================%%
%% NOTA(Pablo): Tal como se ha reorganizado esta sección, esto ha quedado ya bastante claro                      %%
%%===============================================================================================================%%
%%
%% Los lenguajes orientados a características son especialmente útiles en el contexto de las líneas de productos
%% software, ya que nos permiten encapsular en módulos bien definidos las diferentes características, tanto comunes %% como variables, que pueden aparecer en cada uno de los productos software pertenecientes a una misma familia. Los %% lenguajes orientados a características tratan de facilitar además la composición de dichos módulos, contribuyendo %% así a que productos específicos dentro de una familia puedan ser creados mediante la simple composición o
%% ensamblado de módulos software relativamente independientes.
%%
%%===============================================================================================================%%

%%============================================================================%%
%% NOTA(Pablo): Con la nueva reestructuración de la sección, esta             %%
%%     argumentación sobra                                                    %%
%%============================================================================%%
% Por ejemplo, a la hora de crear un tipo abstracto de datos pila, podemos
% considerar diferentes variaciones:
% \begin{description}
%     \item[Básicas:] Toda pila, para ser considerada pila, debe soportar las
%            operaciones \imp{apilar} y \imp{desapilar}.
%     \item[Contador:] Añade un contador para conocer el tamaño de la pila.
%     \item[Bloqueo:] Permite bloquear la pila para evitar modificaciones en su
%            estado.
%     \item[Deshacer:] Agrega la funcionalidad de restaurar el estado de la pila %            antes del último acceso a la misma.
% \end{description}
%
% El objetivo de la programación orientada a características sería encapsular
% cada una de las cuatro funcionalidades anteriores en módulos independientes y
% fácilmente componibles. De esta forma, se podrían obtener diferentes productos % mediante la simple composición de conjuntos diferentes de características. Por % ejemplo, un determinado usuario podría estar interesado en una pila con
% contador, por lo que compondría estas dos características y descartaría las
% demás. Otro usuario podría encontrar más adecuada una pila con bloqueo y
% deshacer, por lo que compondría estas tres características y dejaría fuera la
% correspondiente al contador.
%
% Por lo tanto, un lenguaje orientado a características nos debe permitir
% descomponer fácilmente un programa en características, las cuales deberían
% encapsularse en módulos bien definidos y tan independientes como sea posible.
% A la hora de crear productos concretos, dichos módulos se compondrían de
% acuerdo a las necesidades de los usuarios.
%%============================================================================%%

%%=====================================================================================================%%
%% NOTA(Pablo): Esto también me parece redundante ahora                                                %%
%%=====================================================================================================%%
%%
%% \subsubsection{Conclusiones}
%%
%% Tras analizar el problema con un lenguaje orientado a objetos como es C\# se podría determinar que
%% sería deseable %% encontrar un nuevo paradigma de  programación, orientado a características, donde
%% se pudiesen obtener fácilmente diferentes versiones de una misma aplicación mediante la simple
%% composición de características. Obviamente no todas las combinaciones de características serían
%% válidas, por ejemplo para una característica de una aplicación para un hogar inteligente que se
%% encargue de realizar un uso eficiente del consumo de energía a través del control de las perdidas
%% por ventanas abiertas, necesitará que las características relacionadas con la calefacción y las
%% ventanas estén seleccionadas. Por tanto, un lenguaje orientado a características debería asegurarse
%% de que el resultado de la composición de un conjunto de características da lugar a aplicaciones
%% válidas y consistentes.
%%
%%=====================================================================================================%%

%%=====================================================================================================%%
%% NOTA(Pablo): Esto también me parece redundante ahora                                                %%
%%=====================================================================================================%%
%%
%% \subsection{Ventajas de los lenguajes orientados a características}
%%
%% Los lenguajes orientados a características nos otorgan una mayor flexibilidad, ya que nos permiten
%% que clases individuales puedan ser compuestas por un conjunto de características, por tanto son
%% especialmente recomendados %% para utilizarlos con las líneas de producción software.
%%
%%=====================================================================================================%%

Para estudiar las ventajas de los lenguajes orientados a características nos basaremos en las facilidades proporcionadas por CaesarJ~\cite{aracic:2006}, aunque ilustraremos los ejemplos con diagramas UML. Para mostrar las ventajas de dicho lenguaje se usará el ya comentado problema de las expresiones\footnote{Dicha implementación se proporciona en el soporte óptico adjunto a esta memoria.}. CaesarJ es un lenguaje de programación orientado a características basado en Java. Para ello trabaja con el concepto de \emph{familia de clases}. Una \emph{familia de clases} es una unidad de encapsulamiento que sirve para agrupar clases relacionadas. Las familias de clases reciben un tratamiento similar al de las clases, soportando relaciones de herencia entre ellas.

Además, CaesarJ también introduce el concepto de \emph{clases virtuales}. Una clase virtual es una clase perteneciente a una familia de clases y que es susceptible de ser heredada y sobreescrita por familias de clases que hereden de la familia de clases que contiene dicha clase virtual. La Figura~\ref{back:fig:caesarJExpressions} ilustra esta situación. Las familias de clases se representan mediante paquetes UML, y herencia entre clases, mediante relaciones \emph{merge}. Cuando una familia de clases hereda de otra, hereda implícitamente todas sus clases virtuales. Si la primera contiene clases virtuales con el mismo nombre que la familia de clases que hereda, entonces la clase virtual de la familia de clases hija hereda de la clase virtual con el mismo nombre de la familia de clases padre. Por ejemplo, en la Figura~\ref{back:fig:caesarJExpressions}, la clase \imp{Mult} de la familia de clases \imp{Eval} heredaría implícitamente de la clase \imp{Mult} de la familia de clases \imp{Basic}. En cada familia de clases hija, se pueden añadir por tanto nuevos atributos y métodos a las clases virtuales de las familias de clases padre. Además, gracias al avanzado sistema de tipos de CaesarJ, se pueden añadir nuevas relaciones de herencia.

%%=====================================================================================================%%
%% HECHO(Pablo): Aquí va haciendo falta un ejemplo, y mejor que el que está en la Figura 1.8. Haz un
%%              ejemplo como el del artículo del FOSD 2010, que se vean las clases dentro de los
%%              paquetes para al menos dos características, por ejemplo expression y eval
%%=====================================================================================================%%
\begin{figure}[ht!]
  % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.60\linewidth]{background/images/CaesarJExpressions.eps} \\
  \caption{Diseño para resolver el problema de las expresiones con CaesarJ}
  \label{back:fig:caesarJExpressions}
\end{figure}

Además, las referencias entre clases se actualizan automáticamente. Por ejemplo, en el caso de la Figura~\ref{back:fig:caesarJExpressions}, aunque no se haga explícitamente, cualquier referencia a una clase del tipo \imp{Expression} dentro de la familia de clases \imp{Eval} se referirá a la clase virtual \imp{Expression} de la familia de clases \imp{Eval} y no a la clase virtual de mismo nombre de la familia de clases \imp{Expressions}. De esta forma, las referencias están siempre actualizadas a su versión más extendida.

Para implementar una línea de productos software, cada característica se considera como una familia de clases.
Dentro de cada familia de clases, cada característica se diseña usando las técnicas tradicionales de la orientación a objetos, tal como se muestra en la Figura~\ref{back:fig:caesarJExpressions}.

%%======================================================================================================%%
%% NOTA(Pablo): Esto ahora quedaría redundante                                                          %%
%%======================================================================================================%%
%%
%% La figura~\ref{back:fig:caesarJExpressions} muestra que por cada operación, tenemos una familia de
%% clases, siendo la familia de clases que encapsula a todas las demás, la denominada \imp{Expressions}.
%% Ésta tiene la estructura de clases representado en la figura \ref{back:fig:expr}, y cada familia de
%% clases lo que hace es redefinir las clases virtuales de \imp{Expressions} con las operaciones
%% necesarias en cada caso.
%%
%%======================================================================================================%%


\begin{figure}[ht!]
 % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.60\linewidth]{background/images/Configuration.eps} \\
  \caption{Composición de las características \imp{Eval} e \imp{Infix} en nuevo producto con CaesarJ}
  \label{back:fig:caesarJConfiguration}
\end{figure}

Para realizar una configuración, es decir, para crear un producto concreto por composición de características, simplemente hay que crear una nueva familia de clases que herede de las familias de clases que correspondan a las características seleccionadas. La figura \ref{back:fig:caesarJConfiguration} muestra como se crearía un producto nuevo mediante la composición de las características \imp{Eval} e \imp{Infix}.

%%======================================================================================================%%
%% HECHO(Pablo): Queda raro haber estado mostrando diagramas hasta ahora y luego poner código, así que   %%
%%              haz un diagrama de una configuración y quita el código                                  %%
%%======================================================================================================%%

%%======================================================================================================%%
%% HECHO(Pablo): Completa este análisis                                                                  %%
%%======================================================================================================%%

A continuación analizamos como la programación orientada a características satisface las propiedades que
debe poseer un lenguaje de programación para la implementación de las líneas de productos software:

\paragraph{Extensión a través de la adición y la sustitución:} En los lenguajes orientados a características, la extensión es llevada a cabo a través de la herencia, al igual que ocurre en los lenguajes orientados a objetos. Salvo que los lenguajes orientados a características poseen herencia múltiple, por lo que es posible extender la funcionalidad de varias clases al mismo tiempo. Por lo tanto, sin demasiada complejidad este tipo de lenguajes nos permiten realizar la extensión de varias características simultáneamente.

\paragraph{Encapsulamiento de características:} Las características suelen estar compuestas por más de una clase, por lo que un buen nivel de encapsulamiento evita aumentar la complejidad cuando queramos componer o extender características. De tal modo que los lenguajes orientados a características contienen mecanismos para el encapsulamiento. Como hemos visto en la figura ~\ref{back:fig:caesarJExpressions}, cada característica es agrupada con todas sus clases en una misma \emph{familia de clases}, lo que nos permite manejar las características sin necesidad de utilizar los elementos individuales de cada una de ellas.

\paragraph{Composición a nivel de característica:} Debido a la existencia de la herencia múltiple y de un buen nivel de encapsulamiento de las características, la composición de las mismas es una tarea sencilla. Por ejemplo, para crear una nueva configuración compuesta por \imp{Eval} e \imp{Infix}, únicamente se necesita crear una nueva clase que extienda a estas dos característica, tal y como se ilustra en la figura ~\ref{back:fig:caesarJConfiguration}. Por lo que si comparamos este proceso con el llevado a cabo en un lenguaje orientado a objetos, observamos una drástica disminución de la complejidad y del tiempo invertido.

\paragraph{Análisis y gestión de la corrección de la composición:} Un alto nivel de encapsulamiento facilita enormemente verificar la correcta composición de características. De este modo, únicamente se debe comprobar que la composición de las características es la adecuada, sin necesidad de preocuparnos por ningún elemento interno de las características. Lo mismo ocurre cuando analizamos restricciones más complejas, el proceso se simplifica notablemente si lo comparamos con un lenguaje orientado a objetos.

Como hemos podido comprobar, utilizar un lenguaje orientado a característica puede ser una muy buena elección si queremos desarrollar líneas de producto software. No obstante, como ya se ha dicho anteriormente (ver Capítulo \ref{chap:introduction}), no todas las empresas están dispuestas a cambiar su lenguaje de programación habitual. Por lo tanto, en el presente proyecto se desarrolla una línea de productos software utilizando C\# y sus clases parciales. De tal modo, pretendemos desarrollar una serie de procedimientos que suplan las carencias que presenten los lenguajes orientados a objetos cuando trabajan con problemas típicos de los lenguajes orientados a características. Por lo que en la siguiente sección se describirá muy brevemente en que consisten las clases parciales de C\# y cómo pueden ser utilizadas para resolver un problema como el de las expresiones.


%%======================================================================================================%%
%% HECHO(Pablo): Aquí dí que todo esto está muy bonito, pero que hay que cambiar el lenguaje de          %%
%%              programación y que las empresas no quieren por los problemas que se comentan en la      %%
%%              introducción y que por tanto lo queremos hacer con C\#, bla bla bla  y enlaza con       %%
%%              la siguiente sección                                                                    %%
%%======================================================================================================%%

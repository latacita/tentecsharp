%=========================================================================%
% Author : Alejandro Pérez Ruiz                                           %
% Author : Pablo Sánchez Barreiro                                         %
% Version: 1.1, 10/06/2011                                                %
% Master Thesis: Background/OO Shortcomings                               %
%=========================================================================%

Para mostrar las dificultades que surgen cuando se trata de implementar una línea de productos software usando orientación a objetos, intentamos crear un diseño de una línea de productos software para el problema de las expresiones.

\begin{figure}[!tb]
  \centering \includegraphics[width=.40\linewidth]{background/images/Expressions.eps} \\
  \caption{Diagrama de clases para las características comunes del problema de las expresiones}
  \label{back:fig:expr}
\end{figure}

\begin{figure}[!tb]
  \centering \includegraphics[width=.50\linewidth]{background/images/PrintInfix.eps} \\
  \caption{Diagrama de clases para las características comunes de impresión
  de operadores infijos}
  \label{back:fig:printInfix}
\end{figure}

La forma natural o tradicional de implementar características usando orientación a objetos es usando la herencia como mecanismo de extensión~\cite{gomma:2007,ziadi:2006}, tal como se muestra en las Figuras~\ref{back:fig:expr} y~\ref{back:fig:printInfix}.

La Figura~\ref{back:fig:expr} muestra el diseño básico para las características comunes. Usando este diseño, lo único que podríamos hacer es crear expresiones, compuestas por literales (\imp{Integer}s), combinados mediante operadores binarios (\imp{Add} y \imp{Mult}).

A continuación, por cada característica a implementar, lo que hacemos es extender las clases de la Figura~\ref{back:fig:expr} mediante herencia añadiendo a cada clase las operaciones necesarias para implementar la característica que corresponda. Por ejemplo, la Figura~\ref{back:fig:printInfix} muestra como se extienden las clases de la Figura~\ref{back:fig:expr} para que soporten la característica de impresión en formato infijo. Por cada clase del diseño básico, creamos una nueva clase que herede de la primera. A la clase hija le damos el mismo nombre que a la padre, pero con \imp{Infix} como sufijo. A cada clase hija le añadimos una operación \imp{print}, que contendrá la funcionalidad necesaria para imprimir un objeto de dicha clase de forma infija. Este proceso lo repetimos para el resto de características (e.g., impresión postfija, evaluación con cortocircuito), obteniendo por cada característica un diseño similar al de la Figura~\ref{back:fig:printInfix}. En el caso de la característica \imp{ShortEval}, heredaríamos de las clases creadas para la característica \imp{Eval} y sobreescribiríamos los métodos de evaluación de cada clase\footnote{En el soporte óptico adjunto a esta memoria se proporciona una implementación completa en C\# para este problema conforme a la técnica descrita}.

Una vez diseñadas e implementadas la diferentes características, el siguiente problema es cómo combinarlas de forma que podamos obtener de la forma más simple y rápida posible productos concretos con diferentes conjuntos de características. La técnica empleada más comúnmente consiste en, por cada clase que deba aparecer en el producto final (e.g. \imp{Add}), crear una nueva clase que herede de sus correspondientes versiones pertenecientes a las características seleccionadas. Por ejemplo, si quisiéramos crear un producto con las características \imp{Eval} e\imp{Infix}, crearíamos una nueva clase \imp{AddEvalInfix} que heredase  de \imp{AddEval} y de \imp{AddInfix}.

Por tanto, para componer características deberemos hacer uso de la herencia múltiple. Por fortuna o por desgracia, la herencia múltiple ha ido desapareciendo poco a poco de los lenguajes de programación orientados a objetos modernos tales como Java~\cite{arnold:2005} o C\#~\cite{albahari:2010}. Actualmente, la práctica general es permitir que una clase pueda heredar de una única clase y de un número indeterminado de interfaces. Esto permite solventar los conocidos problemas de conflictos por colisión de comportamientos heredados. No obstante, en ausencia de este tipo de conflictos, la herencia múltiple es un mecanismo muy útil~\cite{meyer:2000,meyer:2009}, por lo que puede que su simple erradicación con el objetivo de evitar ciertas conflictos no sea una idea tan acertada como parece y cuya validez sólo conoceremos con el paso del tiempo.

La solución para trabajar con herencia múltiple en lenguajes orientados a objetos con herencia simple, tipo Java y C\#, es aplicar el \emph{patrón mixin}~\cite{david:1986}. De acuerdo a dicho patrón, que se ilustra en la Figura~\ref{back:fig:mixin}, sólo se heredan de interfaces. Por lo tanto, cada clase de la que deba ser posible heredar deberá tener asociada una interfaz que contenga los métodos de dicha clase. Cuando una clase quiera heredar de dos o más clases, heredará de sus interfaces. Esto hace que se herede el tipo de las interfaces y consecuentemente la cabecera de las operaciones de las interfaces. Es decir, de acuerdo con la Figura~\ref{back:fig:mixin}, la clase \imp{IntegerInfixEval} podrá aparecer en cualquier sustitución de un objeto del tipo \imp{IIntegerInfix} o \imp{IIntegerEval}, y, consecuentemente, deberá contener los métodos \imp{print} y \imp{eval}. No obstante, no se hereda el comportamiento de dichas operaciones.

La solución para reutilizar dicho comportamiento es que la clase que hereda de las interfaces contenga una referencia a las clases que las implementan, haciendo uso de la \emph{reutilización por composición}. De este modo, la clase \imp{IntegerInfixEval} de la Figura~\ref{back:fig:mixin}, posee referencias, denominadas \imp{mixins}, a las clases \imp{IntegerInfix} e \imp{IntegerEval}, que contienen las implementaciones de los métodos \imp{print} y \imp{eval}, respectivamente. Por tanto, para implementar cada método de las interfaces, la clase \emph{delega} en el método que corresponda del mixin que corresponda. Por ejemplo, para implementar el método \imp{eval}, la clase \imp{IntegerInfixEval} delegará en el método \imp{eval} de su referencia \imp{mixinIntegerEval}.

%%===================================================================================%%
%% HECHO(Pablo): Poner una nota para mostrar como se delega en la siguiente figura    %%
%%              Que delegue la operación eval                                        %%
%%              Poner las operaciones en todas las clases                            %%
%%              Los extremos de asociación están mal puestos                         %%
%%===================================================================================%%

\begin{figure}[!tb]
  \centering \includegraphics[width=.55\linewidth]{background/images/MixinPattern.eps} \\
  \caption{El patrón \emph{mixin}}
  \label{back:fig:mixin}
\end{figure}

A continuación analizamos como la solución orientada a objetos descrita hasta ahora satisface las propiedades deseables en un lenguaje de programación para la implementación de líneas de productos software:

\paragraph{Extensión a través de la adición y la sustitución:} En los lenguajes orientados a objetos, la extensión se realiza a través de la herencia. Como ya hemos expuesto, la herencia resulta adecuada cuando queremos extender la funcionalidad de una sola clase. No obstante, la implementación de una característica necesita extender varias clases al mismo tiempo, requiriendo el uso de herencia múltiple, actualmente no soportada por la mayoría de los lenguajes. El patrón mixin, aún permitiendo la herencia múltiple, introduce una cierta complejidad adicional en la extensión de varias características simultáneamente. Además, dado que no sabemos a priori si una clase va a participar o no en una relación de herencia múltiple, por cada clase que creemos, deberemos crear su interfaz, para permitir que dicha clase pueda ser usada aplicando el patrón mixin. La sustitución se realiza por simple sobreescritura de métodos.

Otro problema adicional es la gestión de las referencias entre clases. La herencia tradicional obliga a que las clases y subclases tengan diferentes nombres, y consecuentemente, diferentes tipos. A medida que vamos creando tipos más concretos, deberíamos ir actualizando las referencias entre clases a esos tipos más concretos. Por ejemplo, en la Figura~\ref{back:fig:expr}, la clase \imp{BinaryOperator} tiene dos referencias a la clase \imp{Expression}. Cuando extendemos estas clases para crear una nueva característica, por ejemplo \imp{Eval}, crearemos nuevas clase \imp{BinaryOperatorEval} y \imp{ExpressionEval} que extiendan de las anteriores. De la misma manera, deberíamos actualizar las referencias de \imp{BinaryOperatorEval} para que en lugar de ser dos objetos de la clase \imp{Expression}, fuesen referencias a objetos de la clase \imp{ExpressionEval}. De otra forma, se podría asignar objetos de la clase \imp{Expression}, los cuales no soportasen la operación \imp{eval}.

Por lo tanto, a la par que heredamos deberemos actualizar las referencias a las clases concretas. A mayor número de características en una línea de productos, las relaciones entre clases concretas se complican potencialmente, lo que da lugar a soluciones difíciles de mantener y actualizar.

\paragraph{Encapsulamiento de características:} Cada característica esta compuesta por varias clases. Para componer o extender cada característica, hay que heredar de sus clases a nivel individual, lo que supone un incremento en la complejidad a la hora de manipular las características. De hecho, podemos crear productos erróneos, porque a la hora de extender las clases de una característica, nada nos impide olvidarnos de extender algunas de ellas. Por ejemplo, a la hora de extender el diseño básico de la Figura~\ref{back:fig:expr} para que soportase la característica \imp{Eval} podríamos olvidar crear una clase \imp{MultEval}, por lo que la características estaría incompleta.

\paragraph{Composición a nivel de característica:} Consecuencia directa de la falta de mecanismos de encapsulamiento de características es que la composición de las mismas se tenga que realizar mediante la selección y composición de los elementos individuales, en este caso clases, que las integran. Además, en el caso de necesidad de composición mediante herencia múltiple, deberemos aplicar el patrón mixin. En este caso, el proceso de composición va más allá de la simple composición de dos clases pertenecientes a características diferentes, pues necesitaremos heredar de las interfaces, añadir los mixins y crear las delegaciones. Realizar esta operación para características compuestas por un número largo de clases puede ser un proceso largo y tedioso.

\paragraph{Análisis y gestión de la corrección de la composición:} Otra consecuencia directa de la falta de encapsulamiento entre características es que es complejo asegurar las corrección de las composiciones de características. Cuando un número largo de características con numerosas clases cada una han de ser compuestas, comprobar que el patrón mixin ha sido instanciado de forma adecuada en cada caso, y que todas las clases han sido debidamente extendidas, puede resultar una tarea bastante larga y tediosa. Además, analizar restricciones más complejas tales como dependencias o exclusiones mutuas entre características, puede resultar un auténtico reto.

La siguiente sección describe la programación orientada a características, la cual surge como una mejora a la orientación a objetos que pretende solventar las deficiencias comentadas en esta sección.

%%==============================================================================================================%%
%% NOTA(Pablo): Lo de arriba parece que se entiende bien sin el ejemplo de abajo, por lo que                    %%
%%==============================================================================================================%%
%%
%% Aún cuando las clases, separadas en paquetes, pertenezcan a una misma característica, es necesario
%% seleccionar qué clases concretas van a ser usadas en un producto específico. Por ejemplo, para incluir la
%% característica impresión infija para una configuración del problema de las expresiones es necesario
%% seleccionar todos los operadores binarios(\imp{AddInfix} y \imp{MultInfix}) y literales (\imp{IntegerInfix})
%% que implementan la característica.
%%
%%==============================================================================================================%%


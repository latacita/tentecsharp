%=========================================================================%
% Author : Alejandro Pérez Ruiz                                           %
% Author : Pablo Sánchez Barreiro                                         %
% Version: 1.1, 10/06/2011                                                %
% Master Thesis: Background/OO Shortcomings                               %
%=========================================================================%

Para mostrar las dificultades que surgen cuando se trata de implementar una línea de productos software usando orientación a objetos, intentamos crear un diseño de una línea de productos software para el problema de las expresiones.

\begin{figure}[!tb]
  \centering \includegraphics[width=.60\linewidth]{background/images/Expressions.eps} \\
  \caption{Diagrama de clases para las características comunes del problema de las expresiones}
  \label{back:fig:expr}
\end{figure}

\begin{figure}[!tb]
  \centering \includegraphics[width=.80\linewidth]{background/images/PrintInfix.eps} \\
  \caption{Diagrama de clases para las características comunes de impresión
  de operadores infijos}
  \label{back:fig:printInfix}
\end{figure}

La forma natural o tradicional de implementar características usando orientación a objetos es usando la herencia como mecanismo de extension~\cite{gomma:2007,ziadi:2006}, tal como se muestra en las Figuras~\ref{back:fig:expr} y~\ref{back:fig:printInfix}.

La Figura~\ref{back:fig:expr} muestra el diseño básico para las características comunes. Usando este diseño, lo único que podríamos hacer es crear expresiones, compuestas por literales (\imp{Integer}s), combinados mediante operadores binarios (\imp{Add} y \imp{Mult}).

A continuación, por cada característica a implementar, lo que hacemos es extender las clases de la Figura~\ref{back:fig:expr} mediante herencia añadiendo a cada clase las operaciones necesarias para implementar la característica que corresponda. Por ejemplo, la Figura~\ref{back:fig:printInfix} muestra como se extienden las clases de la Figura~\ref{back:fig:expr} para que soporten la característica de impresión en formato infijo. Por cada clase del diseño básico, creamos una nueva clase que herede de la primera. A la clase hija le damos el mismo nombre que a la padre, pero con \imp{Infix} como sufijo. A cada clase hija le añadimos una operación \imp{print}, que contendrá la funcionalidad necesaria para imprimir un objeto de dicha clase de forma infija. Este proceso lo repetimos para el resto de características (e.g., impresión postfija, evaluación con cortocircuito), obteniendo por cada característica un diseño similar al de la Figura~\ref{back:fig:printInfix}. En el caso de la característica \imp{ShortEval}, heredaríamos de las clases creadas para la característica \imp{Eval} y sobreescribiríamos los métodos de evaluación de cada clase.

Una vez diseñadas e implementadas la diferentes características, el siguiente problema es cómo combinarlas de forma que podamos obtener de la forma más simple y rápida posible productos concretos con diferentes conjuntos de características. La técnica empleada más comúnmente consiste en, por cada clase que deba aparecer en el producto final (e.g. \imp{Add}), crear una nueva clase que herede de sus correspondientes versiones pertenecientes a las características seleccionadas. Por ejemplo, si quisiéramos crear un producto con las características \imp{Eval} e\imp{Infix}, crearíamos una nueva clase \imp{AddEvalInfix} que heredase  de \imp{AddEval} y de \imp{AddInfix}.

Por tanto, para componer características deberemos hacer uso de la herencia múltiple. Por fortuna o por desgracia, la herencia múltiple ha ido desapareciendo poco a poco de los lenguajes de programación orientados a objetos modernos tales como Java~\cite{arnold:2005} o C\#~\cite{albahari:2010}. Actualmente, la práctica general es permitir que una clase pueda heredar de una única clase y de un número indeterminado de interfaces. Esto permite solventar los conocidos problemas de conflictos por colisión de comportamientos heredados. No obstante, en ausencia de este tipo de conflictos, la herencia múltiple es un mecanismo muy útil~\cite{meyer:2000,meyer:2009}, por lo que puede que su simple erradicación con el objetivo de evitar ciertas conflictos no sea una idea tan acertada como parece y cuya validez sólo conoceremos con el paso del tiempo.

La solución para trabajar con herencia múltiple en lenguajes orientados a objetos con herencia simple, tipo Java y C\#, es aplicar el \emph{patrón mixin}~\cite{david:1986}. 

% Por aquí

De acuerdo con dicho patrón, que se ilustra en la Figura \ref{back:fig:mixin}, se utilizan las interfaces para simular la herencia múltiple. Por lo tanto, cada clase a heredar implementará una nueva interfaz que defina los métodos de esta clase, a su vez la nueva clase que se quiere crear para que herede la funcionalidad de sendas clases implementará las dos nuevas interfaces creadas anteriormente, y tendrá una relación de agregación con las clases a heredar.

\begin{figure}[!tb]
  \centering \includegraphics[width=.60\linewidth]{background/images/MixinPattern.eps} \\
  \caption{Diagrama de clases que hace uso del \emph{patrón mixin}}
  \label{back:fig:mixin}
\end{figure}

Pero el uso del \emph{patrón mixin} hace que, un incremento de funcionalidad representado por un conjunto de nuevas subclases que heredan de un conjunto de clases superiores, no sea posible manejarlo como un solo módulo. La insuficiente encapsulación deriva en un incremento de la complejidad a la hora de configurar y construir nuevos productos por ensamblando o composición de características. Aún cuando las clases, separadas en paquetes, pertenezcan a una misma característica, es necesario seleccionar qué clases concretas van a ser usadas en un producto específico. Por ejemplo, para incluir la característica impresión infija para una configuración del problema de las expresiones es necesario seleccionar todos los operadores binarios(\imp{AddInfix} y \imp{MultInfix}) y literales (\imp{IntegerInfix}) que implementan la característica.

Otro problema es el manejo de las dependencias, ya que la herencia tradicional obliga a que las clases y subclases tengan diferentes nombres. Por lo tanto, las referencias a las clases concretas deben ser actualizadas. A mayor número de características en una línea de productos, las relaciones entre clases concretas se complican potencialmente, lo que resulta una situación indeseable. Esto incrementa la complejidad en las relaciones y dependencias entre clases.Por ejemplo, en la característica impresión infija no sería permitido una clase \imp{Add} o \imp{Mult}. Se tienen que crear dos clases concretas, que hereden de \imp{Add} y \imp{Mult}, con diferentes nombres, \imp{AddInfix} y \imp{MultInfix}. Esto incrementa la complejidad en las relaciones y dependencias entre clases.

\paragraph{Extensión a través de la adición y la sustitución:}

En los lenguajes orientados a objetos, la extensión se realiza a través de la herencia, pero como ya hemos expuesto, ésta sólo resulta adecuada cuando queremos extender la funcionalidad de una sola clase. No obstante, la implementación de una característica necesita extender varias clases al mismo tiempo.

Además la extensibilidad no siempre se realiza por adición, en ocasiones es necesario el uso de la sustitución. En los lenguajes orientados a objetos la sustitución se realiza mediante la  sobreescritura (\emph{overriding}, en inglés).

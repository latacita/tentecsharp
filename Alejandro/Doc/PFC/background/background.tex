%=============================================================================%
% Author : Alejandro Pérez Ruiz                                               %
% Author : Pablo Sánchez Barreiro                                             %
% Version: 1.0, 07/03/2011                                                    %
% Master Thesis: Background, master file                                      %
%=============================================================================%
\chapterheader{Antecedentes}{Antecedentes}

\label{chap:background}


% Introducción al capítulo

\chaptertoc

\section{Líneas de Productos Software}

% Explica que es una línea de productos software, objetivos y terminología
% \footnote{}
Una línea de productos software (SPL) es un conjunto de sistemas de software que comparten un conjunto común y gestionado de aspectos que satisfacen las necesidades específicas de un segmento de mercado o misión y
que son desarrollados a partir de un conjunto común de activos fundamentales [de software] de una manera prescrita \cite{clements:2002}\\\\
El objetivo de una Línea de Productos Software \cite{pohl:2005} es crear una infraestructura adecuada a partir de la cual se puedan derivar, tan automáticamente como sea posible, productos concretos pertenecientes a una familia de productos software. Una familia de productos software es un conjunto de aplicaciones software similares, que por tanto comparten una serie de características comunes, pero que también presentan variaciones entre ellos.\\\\
Un ejemplo clásico de familia de productos software es el software que se entrega con un teléfono móvil. Dicho software contiene una serie de facilidades comunes, tales como agenda, recepción de llamadas, envío de mensajes de texto, etc. No obstante, dependiendo de las capacidades y coste asociado al dispositivo móvil, éste puede presentar diversas funcionalidades opcionales, tales como envío de correos electrónicos, posibilidad de conectarse a Internet mediante red inalámbrica, radio, etc.\\\\
La idea de una Línea de Productos Software es proporcionar una forma automatizada y sistemática de construir un producto concreto dentro de una familia de productos software mediante la simple especificación de que características deseamos incluir dentro de dicho producto. Esto representa una alternativa al enfoque tradicional, el cual se basaba simplemente en seleccionar el producto más parecido dentro de la familia al que queremos construir y adaptarlo manualmente.


\section{Programación Orientada a Características}

% Objetivos de la orientación a características
Los lenguajes orientados a características, tienen como objetivo encapsular conjuntos coherentes de la funcionalidad de un sistema software en módulos independientes y fácilmente componibles para permitirnos alcanzar una mejor extensibilidad y reusabilidad. Estos módulos reciben el nombre de característica.
Una característica se puede definir como un incremento de la funcionalidad de un sistema \cite{batory:2004}.\\
Estos lenguajes son especialmente útiles en el contexto del desarrollo de líneas de producción software, ya que nos permiten separar las características comunes de la mayoría de los productos de la línea de producción de las características que varían de producto a producto.


\subsection{Limitaciones de la Orientación a Objetos frente a la Programación Orientada a Características}

% Limitaciones de los lenguajes OO para FOP
Para analizar las limitaciones que posee la programación orientada a objetos frente a la programación orientada a características se ha hecho uso del problema estándar de las líneas de productos de las expresiones(en inglés, Expression Product-Line). Éste es un problema fundamental en el diseño del software, que consiste en la extensión de nuevas operaciones y representación de los datos para su posterior combinación. Ha sido ampliamente estudiado dentro del contexto del diseño de los lenguajes de programación, donde se enfocaba en lograr la extensibilidad de los tipos de datos y las operaciones de una manera segura.Pero en vez de concentrarnos en este tema, consideraremos los aspectos del diseño y la síntesis del problema de producir una familia de productos. Más concretamente, ¿qué características están presentes en el problema?¿Cómo las podemos modularizar? Y ¿cómo podemos construir diferentes configuraciones?

\subsubsection{Descripción del problema de las expresiones}

El objetivo es definir los diferentes tipos de datos para representar la gramática mostrada en la figura \ref{back:fig:gramExpr}.\\

\begin{figure}
\begin{center}
\begin{footnotesize}
\begin{verbatim}
Exp :: = Integer | AddInfix | MultInfix | AddPostfix | MulltPostfix |
		         AddPrefix | MultPrefix
Integer     :: <positive-negative integers>
AddInfix    ::= Exp "+" Exp
MultInfix   ::= Exp "*" Exp
AddPostfix  ::= Exp Exp "+"
MultPostfix ::= Exp Exp "*"
AddPrefix   ::= "+" Exp Exp
MultPrefix  ::= "*" Exp Exp
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Gramática del lenguaje de expresiones}
\label{back:fig:gramExpr}
\end{figure}
Tres operaciones para las expresiones serán definidas en esta gramática: \begin{enumerate} \item \imp{Print}: mostrará por consola la expresión en el formato correspondiente(infijo, prefijo o posfijo).\item \imp{Eval}: evaluará la expresión y retornará el valor numérico. \item \imp{ShortEval}: evaluará la expresión realizando la operación de multiplicación cortocircuitada, es decir, si el primer operando es 0 directamente retornará el valor 0 para la expresión.
\end{enumerate}
Teniendo el problema presente podemos identificar dos conjuntos de características, por un lado las operaciones \imp{\{Print, Eval, ShortEval\}} y por otro los tipos de datos \imp{\{AddInfix, MultInfix, AddPostfix...\}}. Por lo tanto, el objetivo es implementar una línea de productos software que nos permita crear las distintas configuraciones posibles para este problema.

\subsubsection{Resolviendo el problema con C\#}

La figura ~\ref{back:fig:expr} representa el diseño de clases UML que soporta las variabilidades identificadas anteriormente. Este diseño es replicado para cada tipo de operación(la figura ~\ref{back:fig:printInfix} muestra el diagrama de clases para la operación de imprimir expresión en formato infijo).\\
\begin{figure}[ht!]
  % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.60\linewidth]{background/images/Expressions.eps} \\
  \caption{Diagrama de clases para el problema de las expresiones}
  \label{back:fig:expr}
\end{figure}
\begin{figure}[ht!]
  % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.80\linewidth]{background/images/PrintInfix.eps} \\
  \caption{Diagrama de clases para la operación de imprimir en formato infijo}
  \label{back:fig:printInfix}
\end{figure}
Tras trasladar estos diagramas a C\# se observan las carencias que posee un lenguaje orientado a objetos cuando implementamos un problema propio de la programación orientada a características.\\
Por un lado he utilizado el mecanismo de herencia para añadir funcionalidades a una clase existente, pero este mecanismo es jerárquico, lo que hace que la clase hija herede toda la funcionalidad de su clase padre.
Por ejemplo, para crear una nueva configuración que contenga las operaciones evaluar e imprimir en formato infijo se necesitaría crear una nueva subclase que heredase de las clases que contienen las operaciones citadas anteriormente, pero esto no es posible, ya que C\#, como la mayoría de los lenguajes orientados a objetos, solo permiten hacer uso de la herencia múltiple entre interfaces. Por lo tanto, por cada clase que se quiera heredar debemos crear una nueva interfaz que sea extendida por la clase a heredar y por la subclase que contendrá la nueva configuración, a través de esto y la creación de objetos de las clases a heredar podremos acceder a los métodos definidos por las interfaces, con lo que se consigue simular la herencia múltiple.\\
Pero el uso de esta técnica hace que, un incremento de funcionalidad representado por un conjunto de nuevas subclases que heredan de un conjunto de clases superiores, no sea posible manejarlo consistentemente como una unidad encapsulada. La insuficiente unidad de encapsulación, deriva en un problema de complejidad en el manejo de la selección de características para la composición. Aun cuando, las clases separadas en paquetes pertenezcan a una misma característica, es necesario seleccionar clases concretas que van a ser usadas en un producto específico.
Otro problema es el manejo de las dependencias, ya que la herencia tradicional obliga a que las clases y subclases tengan diferentes nombres. Por lo tanto, las referencias a las clases concretas deben ser actualizadas. A mayor número de características en una línea de productos, las relaciones entre clases concretas se complican potencialmente, lo que resulta una situación indeseable. Esto incrementa la complejidad en las relaciones y dependencias entre clases.
% - Cuentas el ejemplo de las expresiones
% - Muestras la solución en C#.

\subsubsection{Conclusiones}

Tras analizar el problema con un lenguaje orientado a objetos como es C\# se podría determinar que sería deseable encontrar en un lenguaje de programación que estuviese orientado a características para obtener fácilmente diferentes versiones de una misma aplicación con la simple combinación de diferentes conjuntos de características. Obviamente no todas las combinaciones serán válidas, por lo tanto, un lenguaje orientado a características debería de intentar asegurarse de que el resultado de la composición produce una aplicación segura y bien configurada.
Con lo citado anteriormente, vamos a identificar una serie de características deseables que deberíamos encontrar en un lenguaje orientado a características:\\\\
\emph{Extensibilidad a través de la adición y la substitución}\\
Como ya hemos comentado, una característica es normalmente considerada como un incremento en la funcionalidad de un programa. Por lo tanto, los lenguajes orientados a características deben proveer mecanismos para añadir nuevas funcionalidades a una existente. En los lenguajes orientados a objetos, la extensión es realizada a través de la herencia, pero ésta es adecuada cuando queremos extender una sola clase, pero comúnmente, las características necesitan ser extendidas por varias clases al mismo tiempo.
Además la extensibilidad no siempre se alcanza por adición, en ocasiones es necesario el uso de la substitución. En los lenguajes orientados a objetos la substitución es llevada a través de métodos de sobre escritura (override en inglés).\\\\
\emph{Encapsulación de características}\\
Todas las extensiones pertenecientes a una característica concreta deben ser añadidas de una forma atómica. Por lo tanto, los lenguajes orientados a características deberían proveer de mecanismo para agrupar y encapsular los módulos pertenecientes a una misma característica. Por otra parte, estos módulos deberían poderse compilar independientemente.\\\\
\emph{Composición a nivel de característica}\\
Productos específicos, o configuraciones de una descomposición orientada a características, son obtenidos por la selección y composición de unas características específicas. Por lo tanto, sería deseable que un lenguaje orientado a características tuviese construcciones del lenguaje para producir un producto en particular. Esto debería ser realizado a nivel de característica, especificando que características deberían ser incluidas, en lugar de tener que especificar los elementos individuales de cada característica.\\\\\\
\emph{Composición de características comprobando la coherencia}\\
No todas las combinaciones de características son válidas. Por lo tanto, un lenguaje orientado a características debería detectar las restricciones, evitando así la implementación de configuraciones no válidas y manejar automáticamente las dependencias en la medida de lo posible.

\subsection{Ventajas de los lenguajes orientados a características}
Los lenguajes orientados a características nos otorgan una mayor flexibilidad, ya que nos permiten que clases individuales puedan ser compuestas por un conjunto de características, por tanto son especialmente recomendados para utilizarlos con las líneas de producción software.\\
Para estudiar las ventajas de los lenguajes orientados a características se trabajará con CaesarJ que es un lenguaje de programación basado en Java, que nos proporciona una mayor modularidad y el desarrollo a través de componentes reusables.Para ello trabaja con conceptos como clases y paquetes en una única entidad, llamada familia de clases, que constituye unidades de encapsulamiento adicional para agrupar clases relacionadas. Una familia de clases también es, en sí misma una clase. Así mismo, se introduce el concepto de clases virtuales, que son clases internas (de familias de clases) propensas a ser refinadas a nivel de subclases. En el refinamiento de una clase virtual, implícitamente se hereda de la clase que refina, por lo que también esto es visto como una relación adjunta. También, en un refinamiento pueden ser añadidos nuevos métodos, campos, relaciones de herencia y sobreescritura de métodos. Puesto que en cada familia de clases, las referencias a las clases virtuales siempre apuntarán al refinamiento más específico. Esto significa que, por medio de las clases virtuales se aplica sobre escritura de métodos, permitiendo redefinir el comportamiento de cualquier subclase de una familia de clases.\\
En términos de programación orientada a características, cada funcionalidad es modelada como una familia de clases. Mientras que los componentes y objetos del dominio específico, son correspondidos por sus clases virtuales. Así mismo, las clases virtuales pueden ser declaradas como clases abstractas, lo que habilita la definición de interfaces en la implementación modular de características.\\\\
Para hacer uso de lo citado anteriormente y ver su beneficio con las líneas de producción software se ha vuelto a utilizar el ya comentado problema de las expresiones de la subsección anterior. Pero en este caso, el diseño cambia significativamente debido a la características expuestas de CaesarJ.\\
Por un lado en la figura \ref{back:fig:caesarJExpressions} se muestra que por cada operación, tenemos una familia de clases, siendo la familia de clases que encapsula a todas las demás, la denominada \imp{Expressions}. Ésta tiene la estructura de clases representado en la figura \ref{back:fig:expr}, y cada familia de clases lo que hace es redefinir las clases virtuales de \imp{Expressions} con las operaciones necesarias en cada caso.\\
\begin{figure}[ht!]
  % Requires \usepackage{graphicx}
  \centering \includegraphics[width=.60\linewidth]{background/images/CaesarJExpressions.eps} \\
  \caption{Diseño para resolver el problema de las expresiones con CaesarJ}
  \label{back:fig:caesarJExpressions}
\end{figure} 
\begin{figure}[ht!]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
00 import eval.Eval;
01 import printPostfix.PrintPostfix;
02 import printInfix.PrintInfix;
03 import printPrefix.PrintPrefix;
04 public cclass EvalInfix extends PrintPrefix & Eval {}
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Configuración que incluye las operaciones de evaluar e imprimir en formato infijo con CaesarJ}
\label{back:fig:codCaesarJ}
\end{figure}

Para realizar configuraciones, únicamente se tiene que crear una nueva clase que extienda a las características que se deseen.A modo de ejemplo,la figura \ref{back:fig:codCaesarJ} muestra el código necesario para crear una nueva configuración que contenga las operaciones de impresión en formato posfijo y evaluación de una expresión.Con todo esto, vemos como CaesarJ otorga un gran nivel de encapsulamiento y de reusabilidad de los componentes.

% Párrafo introducción
% Introducción CaesarJ
% Ejemplo en CeasrJ, resaltando ventajas

\section{Clases Parciales C\#}
Las clases parciales C\# \cite{albahari:2010} nos permiten dividir la implementación de una clase, estructura o interfaz en varios archivos de código fuente. Cada fragmento representa una parte de la funcionalidad global de la clase. Todos estos fragmentos se combinan en tiempo de compilación para crear una única clase, la cual contiene toda la funcionalidad especificada en las clases parciales. Por lo tanto,las clases parciales C\# pueden utilizarse como un mecanismo adecuado para implementar características, dado que cada incremento en funcionalidad para una clase se podría encapsular en una clase parcial separada.\\\\
Para poder ser compiladas y agrupadas en una sola clase, todas las clases parciales deben pertenecer al mismo espacio de nombres, poseer la misma visibilidad y deben ser declaradas con el indicador clave partial. En C\#, un espacio de nombre es simplemente empleado para agrupar clases relacionadas y evitar conflictos de nombres. Para especificar los archivos C\# que deben ser incluidos en una compilación, se emplea un documento XML que contiene información acerca del proyecto y que especifica que ficheros deben ser compilados para generar el proyecto. Por lo tanto, es posible incluir y excluir fácilmente la funcionalidad encapsulada dentro de una clase parcial simplemente añadiendo o eliminando dicha clase parcial de este fichero XML.\\\\
Para ilustrar lo dicho anteriormente, se ha vuelto a utilizar el problema de las expresiones implementándolo con clases parciales. La figura \ref{back:fig:partialClass} muestra como hemos excluido de la compilación la característica que representa la operación de imprimir una expresión en formato infijo.
Este mecanismo de clases parciales permite añadir o compartir funcionalidad entre un conjunto de clases que no precisan estar relacionadas mediante ningún tipo de relación jerárquica, tal como ocurre con la herencia.\\
Por lo tanto, algunos autores (Laguna et al, 2007) sostienen que, las clases parciales C\# representan una alternativa a la herencia múltiple para manejar variabilidad relacionada programación orientada a características.
\begin{figure}[!t]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
01    <itemgroup>
02    <!--Eval-->
03    <Compile Include="Eval\Add.cs" />
04    <Compile Include="Eval\IExpressionsEval.cs" />
05    <Compile Include="Eval\IExpressions.cs" />
06    <Compile Include="Eval\Integer.cs" />
07    <Compile Include="Eval\Mult.cs" />
08    <!--Infix-->
09    <!--<Compile Include="Infix\Add.cs" />
10    <Compile Include="Infix\IExpressionInfix.cs" />
11    <Compile Include="Infix\IExpressions.cs" />
12    <Compile Include="Infix\Integer.cs" />
13    <Compile Include="Infix\Mult.cs" />-->
14    ...
15    </itemgroup>
16    </Project>
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Implementación del archivo XML que guarda la información para la compilación}
\label{back:fig:partialClass}
\end{figure}

% Qué hace esto aquí

% Explicar que son brevemente, y ejemplo usando las expresiones

